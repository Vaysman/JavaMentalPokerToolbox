This is libTMCG.info, produced by makeinfo version 4.13 from
libTMCG.texi.

This is the reference manual of LibTMCG.

   Revision $Id: libTMCG.texi,v 1.54 2007/05/07 16:42:36 stamer Exp $.

   Copyright (C) 2005, 2006, 2007 Heiko Stamer <<stamer@gaos.org>>.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts. A copy of the license is included in the
     section entitled "GNU Free Documentation License".


File: libTMCG.info,  Node: Top,  Next: Introduction,  Up: (dir)

LibTMCG Reference Manual
************************

* Menu:

* Introduction::
* Application Programming Interface::
* Examples::
* Licenses::
* General and API Index::

   This is the reference manual of LibTMCG.

   Revision $Id: libTMCG.texi,v 1.54 2007/05/07 16:42:36 stamer Exp $.

   Copyright (C) 2005, 2006, 2007 Heiko Stamer <<stamer@gaos.org>>.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts. A copy of the license is included in the
     section entitled "GNU Free Documentation License".


File: libTMCG.info,  Node: Introduction,  Next: Application Programming Interface,  Prev: Top,  Up: Top

1 Introduction
**************

`LibTMCG' is a C++ library for creating secure and fair online card
games. The library contains a sort of useful classes, algorithms, and
high-level protocols to support an application programmer in writing
such software. The most remarkable feature is the absence of a trusted
third party (TTP), i.e., neither a central game server nor trusted
hardware components are necessary. Thus, with the present library there
is no need for an independent referee, because the applied protocols
provide a basic level of confidentiality and fairness by itself.
Consequently, the library is well-suited for peer-to-peer (P2P)
environments where no TTP is available.  Of course, we cannot avoid
that malicious players share information about their private cards, but
the protocols ensure that the shuffle of the deck is performed randomly
(presumed that at least one player is honest) and thus the cards will
be distributed uniformly among the players.  Further, no coalition can
learn the private cards of a player against his will (except for
trivial conclusions). The corresponding cryptographic problem, actually
called "Mental Poker", has been studied since 1979 (Shamir, Rivest, and
Adleman) by many authors.  LibTMCG provides the first practical
implementation of such protocols.

   The security and the fairness rely on advanced cryptographic
techniques--the so-called zero-knowledge proofs. Using these `building
blocks' the high-level protocols minimize the effect of coalitions and
preserve the confidentiality of the players' strategy, i.e., the
players are not required to reveal their cards at the end of the game
to show that they did not cheat. This important property is often
required in card games like Poker.

   LibTMCG is _Free Software_ according to the definition of the Free
Software Foundation. The source code is released under the GNU _General
Public License_ Version 2.

* Menu:

* Further Reading::
* Getting Started::
* Preliminaries::
* Preparation::
* Header Files and Name Spaces::
* Building Sources::
* Initializing the Library::


File: libTMCG.info,  Node: Further Reading,  Next: Getting Started,  Up: Introduction

1.1 Further Reading
===================

The cryptographic background and a detailed discussion of the
implementation issues are beyond the scope of this manual.  The
interested reader is referred to the following papers:

     [Sc98]: 	CHRISTIAN SCHINDELHAUER.  	_Toolbox for Mental
     Card Games._
     	Technical Report A-98-14, University of Lu"beck, 1998.
     	`http://citeseer.ist.psu.edu/schindelhauer98toolbox.html'

     [BS03]: 	ADAM BARNETT and NIGEL P. SMART.  	_Mental Poker
     Revisited._
     	In K.G. Paterson (Ed.): Cryptography and Coding 2003, 	Lecture
     Notes in Computer Science 2898, pp. 370-383, 2003.

     [Gr05]: 	JENS GROTH.  	_A Verifiable Secret Shuffle of
     Homomorphic Encryptions._
     	Cryptology ePrint Archive, Report 2005/246, 2005.
     	`http://eprint.iacr.org/2005/246'

     [St04]: 	HEIKO STAMER.  	_Kryptographische Skatrunde._ (in
     German)
     	Offene Systeme (ISSN 1619-0114), 4:10-30, 2004.
     	`http://www.gaos.org/~stamer/OS-4-2004-openskat_rev2005.pdf'

     [St05]: 	HEIKO STAMER.  	_Efficient Electronic Gambling: An
     Extended Implementation 	of the Toolbox for Mental Card Games._
     	Proceedings of the Western European Workshop on Research in
     Cryptology (WEWoRC 2005), Lecture Notes in Informatics P-74,
     pp. 1-12, 2005.
     	`http://www.gaos.org/~stamer/WEWoRC2005_proc.pdf'


File: libTMCG.info,  Node: Getting Started,  Next: Preliminaries,  Prev: Further Reading,  Up: Introduction

1.2 Getting Started
===================

This manual describes the application programming interface of LibTMCG.
All relevant data types, public classes and security parameters are
explained. The reader should have an advanced knowledge in applied
cryptography and C++ programming. Reference is made at this point to
the famous `Handbook of Applied Cryptography' for a brief introduction.

   This document follows, in style and rarely in phrasing, the
`Reference Manual of the GNU Crypto Library'.  Thus don't be surprised,
if you recognize some obvious analogies.


File: libTMCG.info,  Node: Preliminaries,  Next: Preparation,  Prev: Getting Started,  Up: Introduction

1.3 Preliminaries
=================

The most card games are played with a regular card deck, i.e., cards
where the pattern on the front side (face) determines the card type
(e.g.  the King of Spades, the Seven of Hearts, the Ace of Club, or the
Jack of Diamonds) and where the back sides of all cards are
indistinguishable.  Only such `regular' card decks are supported by
LibTMCG.

* Menu:

* Terminology::
* Security::


File: libTMCG.info,  Node: Terminology,  Next: Security,  Up: Preliminaries

1.3.1 Terminology
-----------------

The following list defines some common terms that are subsequently used
in the manual.

     Player: 	A _player_ is an active participant in an electronic
     card 	game.

     Observer: 	An _observer_ is an passive party who watches
     the	game.

     Card: 	The term _card_ means the electronic representation of
     a playing 	card.

     Card Type: 	The _card type_ is a nonnegative integer which
     corresponds 	to the pattern on the picture side of a real
     playing card. We 	assume here that such a natural encoding always
     exists.

     Masking: 	_Masking_ is a process which aim is to transform the
     card 	representation such that the input card and the result
     cannot 	be linked (except for trivial conclusions). Roughly
     speaking, masking 	is the (re-)encryption of a card representation
     such that the 	original card type is preserved.

     Card Secret: 	The _card secret_ contains all random values
     used in a masking 	operation. These values must be kept secret
     until the card is 	publicly revealed. Otherwise the corresponding
     output of the masking 	transformation is linkable and other
     players may learn the card type.

     Open Card: 	An _open card_ is a card whose type can be
     easily 	determined by all players and usually by observers as
     well.

     Masked Card: 	A _masked card_ (also known as face-down card)
     is a card whose 	type is unknown to a subset of players. It can
     be only revealed, if 	all players cooperate in a common
     computation of the type.

     Private Card: 	A _private card_ is a card whose type is only
     known to its 	owner. As long as the owner does not corporate
     the type of the 	private card stays hidden to all other players
     (except for trivial 	conclusions).

     Stack: 	A _stack_ is a not necessarily disjoint subset of the
     whole 	card deck.

     Prover and Verifier: 	The _prover_ is a player who shows some
     property to another 	party called _verifier_. For example,
     he wants to show that 	a masking operation was performed
     correctly, i.e., the card type 	is preserved by the
     transformation.


File: libTMCG.info,  Node: Security,  Prev: Terminology,  Up: Preliminaries

1.3.2 Security
--------------

"Mental Poker" solutions cannot prevent that malicious players exchange
private information, for example, by telephone or Internet chat.
Cryptographic protocols can only minimize the effect of such colluding
parties and should try to protect the confidentiality for honest
players. But even this small protection often relies on
number-theoretical assumptions which are only believed to be true,
i.e., problems like factoring products of large primes or computing
discrete logarithms are only believed to be hard. That means, strict
mathematical proofs(1) for the hardness of these problems are not
known, and it is not very likely that such proofs will ever be found.
However, almost all public key cryptosystems rely on such assumptions
and therefore you should not care about this issue, as long as
reasonable security parameters are chosen.

   LibTMCG was designed to provide security in the "honest-but-curious"
(aka semi-honest) adversary model. That means, all participants follow
the protocol instructions properly but they may gather information and
share them within a coalition to obtain a game advantage. Thus we are
not concerned with robustness and availability issues which are hard to
solve in asynchronous environments like the Internet. However, the most
operations are verifiable such that cheating can be detected. To obtain
this verifiability, the protocols deploy so-called zero-knowledge proofs
which yield no further knowledge but the validity of a statement. The
soundness error of these proofs is bounded by a security parameter t.
Depending on your application scenario this parameter should be chosen
such that there is a reasonable tradeoff between the cheating
probability (which is less or equal than 2^-t) and the produced
computational and communication complexity.

   Unfortunately, in practice there is a substantial problem with the
detection of cheaters. Reliable cheater detection requires that an
authenticated broadcast channel has been established, where all players
have read/write access. LibTMCG does not yet contain the necessary
protocols (reliable broadcast or even atomic broadcast) for creating
such a channel. Thus you should take into account that not necessarily
the player acting as prover is the source of evil, if a verification
procedure fails. This level of uncertainty is also a reason for our
restricted adversary model.

   Note that it is not known, whether the used protocols retain their
zero-knowledge property, if they are composed and executed in a
concurrent setting. Thus the application programmer should be careful
and avoid parallel protocol sessions. It is an open research project to
create a protocol suite whose security can be proven in the
UC-framework of Canetti (see _Universally Composable Security: A New
Paradigm for Cryptographic Protocols_, Cryptology ePrint Archive:
Report 2000/067). Furthermore, the protocols should employ concurrent
zero-knowledge proofs (see Dwork, Naor, Sahai: _Concurrent
Zero-Knowledge_, Journal of the ACM 51(6):851-898, 2004).

   LibTMCG was carefully implemented with respect to timing attacks
(see Kocher: _Cryptanalysis of Diffie-Hellman, RSA, DSS, and other
cryptosystems using timing attacks_, CRYPTO '95, LNCS 963, 1995).
Therefore we loose some efficiency, e.g., during modular
exponentiations. However, it is strongly recommended to leave the
timing attack protection turned on, unless you know exactly where it is
really not needed.

     Security Advice: We have implemented all cryptographic primitives
     according to the cited research papers and to the best of our
     knowledge. However, we can not eliminate any possibility of
     contained flaws or bugs, because the implementation of such
     complex protocols is always an error-prone process. Thus we
     encourage readers with advanced cryptographic background to review
     the source code of LibTMCG. Please report any complaint or
     correction proposal.

   ---------- Footnotes ----------

   (1) For instance, a "tight reduction" to a known hard problem in the
sense of complexity theory.


File: libTMCG.info,  Node: Preparation,  Next: Header Files and Name Spaces,  Prev: Preliminaries,  Up: Introduction

1.4 Preparation
===============

LibTMCG depends on three other basic libraries. Therefore you will need
the corresponding development files to build LibTMCG and your
application properly. The following list gives a short exposition of
the used features and specifies the required versions:


   * GNU Multiple Precision Arithmetic Library (`libgmp'),
     Version \ge 4.1.0

     		The library provides a powerful framework for performing
     arbitrary precision arithmetic on integers. Further reasons
     for choosing this dependency are the license compatibility,
     the portability, the vital maintenance, and of course, the
     reasonable performance.



   * GNU Crypto Library (`libgcrypt'), 		Version \ge 1.2.0

     		The library provides some basic cryptographic algorithms
     (e.g. RIPEMD-160) and an easily accessible interface for
     cryptographically strong pseudo random numbers.



   * GNU Privacy Guard Error Code Library (`libgpg-error'),
     Version \ge 0.5

     		This library defines common error values, e.g.,
     returned by the 		GNU Crypto Library.
   We suppose that the reader is familiar with these libraries because
their correct installation, configuration, and usage is crucial to the
security of the entire application.


File: libTMCG.info,  Node: Header Files and Name Spaces,  Next: Building Sources,  Prev: Preparation,  Up: Introduction

1.5 Header Files and Name Spaces
================================

The interface definitions of classes, data types, and security
parameters(1) are provided by the central header file `libTMCG.hh'. You
have to include this file in all of your sources, either directly or
through some other included file.  Thus often you will simply write:

     #include <libTMCG.hh>

   There are no uniform C++ name spaces for the most parts of the
library. Some classes and data types have the common prefix `TMCG_*'
resp. `VTMF_*' while others are composed of the author names and an
abbreviation of the title from the related research paper. Further
there are internally used C functions which might produce conflicting
names. These function names are prepended by `mpz_*' because they are
extensions for the large integer support of the GNU Multiple Precision
Arithmetic Library.

   ---------- Footnotes ----------

   (1) The security parameters are fixed at compile time of LibTMCG.
Please don't change anything unless you know exactly what you are
doing! Beside the apparent security concerns you will probably break
the compatibility with other LibTMCG applications.


File: libTMCG.info,  Node: Building Sources,  Next: Initializing the Library,  Prev: Header Files and Name Spaces,  Up: Introduction

1.6 Building Sources
====================

If you want to compile a source file including the `libTMCG.hh' header,
you must make sure that the compiler can find it in the directory
hierarchy. This is achieved by adding the path of the corresponding
directory to the compilers include file search path.

   However, the path to the include file has been determined at the time
the source is configured. To solve this problem, LibTMCG ships with a
small helper program `libTMCG-config' that knows the path to the
include file and a few other configuration options. The options that
need to be added to the compiler invocation are output by the
`--cflags' option to `libTMCG-config'. The following example shows how
it can be used at the command line:

     g++ -c foo.cc `libTMCG-config --cflags`

   Adding the output of `libTMCG-config --cflags' to the compilers
command line will ensure that the compiler can find the LibTMCG header
file.

   A similar problem occurs when linking your program with LibTMCG.
Again, the compiler has to find the library files. Therefore the
correct installation path has to be added to the library search path.
To achieve this, the option `--libs' of `libTMCG-config' can be used.
For convenience, this option also outputs all other stuff that is
required to link your program with LibTMCG (in particular, the `-lTMCG'
option).

   The example shows how to link `foo.o' with LibTMCG to a program
called `foo':

     g++ -o foo foo.o `libTMCG-config --libs`

   Of course, you can also combine both examples to a single command by
calling the shell script `libTMCG-config' with both options:

     g++ -o foo foo.c `libTMCG-config --cflags --libs`

1.6.1 Building Sources Using GNU Automake
-----------------------------------------

You can use GNU Automake to obtain automatically generated Makefiles.
If you do so then you do not have to care about finding and invoking
the `libTMCG-config' script at all.  LibTMCG provides an Automake
extension that does all the stupid work for you.

 -- Macro: AM_PATH_LIBTMCG ([MINIMUM-VERSION], [ACTION-IF-FOUND],
          [ACTION-IF-NOT-FOUND])
     Check whether LibTMCG (at least version MINIMUM-VERSION, if given)
     exists on the host system. If it is found, execute ACTION-IF-FOUND,
     otherwise do ACTION-IF-NOT-FOUND.

     Additionally, the macro defines `LIBTMCG_CFLAGS' to the flags
     needed for compilation in order to find the necessary header
     files, and `LIBTMCG_LIBS' to the corresponding linker flags.

   You can use the defined variables in your `Makefile.am' as follows:

     AM_CPPFLAGS = $(LIBTMCG_CFLAGS)
     LDADD = $(LIBTMCG_LIBS)


File: libTMCG.info,  Node: Initializing the Library,  Prev: Building Sources,  Up: Introduction

1.7 Initializing the Library
============================

The first step is the initialization of LibTMCG. The following function
must be invoked early in your program, i.e., before you make use of any
other capability of LibTMCG.

 -- Function: bool init_libTMCG ()
     The function checks whether the installed third-party libraries
     match their required versions. Further it initializes them and
     returns `true', if everything was sound. Otherwise `false' is
     returned and an appropriate error message is sent to `std::cerr'.

   Additionally, the function `version_libTMCG' returns a string
containing the version number of the library in a common format. It is
strongly recommended to check, whether the installed version matches
your requirements.

 -- Function: std::string version_libTMCG ()
     This function returns the version of the library in the format
     _major.minor.revision_.


File: libTMCG.info,  Node: Application Programming Interface,  Next: Examples,  Prev: Introduction,  Up: Top

2 Application Programming Interface
***********************************

* Menu:

* Preprocessor Defined Global Symbols::
* Data Types and Classes::


File: libTMCG.info,  Node: Preprocessor Defined Global Symbols,  Next: Data Types and Classes,  Up: Application Programming Interface

2.1 Preprocessor Defined Global Symbols
=======================================

Please note that the following macros are fixed at compile time of
LibTMCG and cannot be changed by your application.  They are only
provided here for informational purposes.

 -- Macro: TMCG_MR_ITERATIONS
     	Defines the number of iterations for the Miller-Rabin primality
     test.  	The default value is `64' which implies a soundness
     error 	probability  \le 4^-64.

 -- Macro: TMCG_GROTH_L_E
     	Defines the security parameter \ell_e of Groth's interactive
     shuffle argument [Gr05]. The default value is `80' which 	implies
     a soundness error probability  \le 2^-80. For the 	intended
     purposes of LibTMCG this bound seems to be reasonable.

 -- Macro: TMCG_DDH_SIZE
     Defines the security parameter (field size in bit) of the group G
     which is used by the card encoding scheme of Barnett and
     Smart [BS03]. The underlying assumptions are DDH, CDH, and DLOG.
     The default value is `1024'.

 -- Macro: TMCG_DLSE_SIZE
     Defines the security parameter (subgroup size in bit) of the group
     G which is used by the card encoding scheme of Barnett and
     Smart [BS03]. The underlying assumptions are DLSE (related to DDH)
     and DLOG. The default value is `160'.

 -- Macro: TMCG_GCRY_MD_ALGO
     Defines the message digest algorithm for digital signatures and
     the Fiat-Shamir heuristic (see Fiat, Shamir: _How to prove
     yourself: Practical Solutions to Identification and Signature
     Problems_, 1986).  The security of the most non-interactive
     zero-knowledge proofs (NIZK) is related to the so-called random
     oracle model, i.e., we suppose that the instantiated hash function
     behaves like an ideal random function (which cannot hold in a real
     world scenario). However, this assumption seems to be reasonable,
     if the hash function is collision-resistant and carefully
     implemented. The default value `GCRY_MD_RMD160' (1) chooses the
     hash algorithm RIPEMD-160 (see Dobbertin, Bosselaers, Preneel:
     _RIPEMD-160, a strengthened version of RIPEMD_, 1996) which has an
     output length of 160 bit. Thus we gain a security level of
     approximately 2^80, assuming that a birthday-attack is the best
     known attack against this hash function.

 -- Macro: TMCG_KEYID_SIZE
     Defines the length (in characters w.r.t. `TMCG_MPZ_IO_BASE') for
     the distinctive suffix of the unique TMCG key identifier. The
     default value is `8' which spans a reasonable name space for at
     least 2^20 different TMCG keys (see `TMCG_PublicKey').  However,
     sometimes it is required to use even smaller sizes.

     Each key identifier starts with the string `"ID"' followed by the
     decimal encoded value of `TMCG_KEYID_SIZE' and the appended carret
     symbol `"^"'. The final suffix contains `TMCG_KEYID_SIZE'
     alphanumerical characters from the self signature of TMCG key. The
     signature has enough entropy included to be used as unique key
     identifier.

 -- Macro: TMCG_KEY_NIZK_STAGE1
     Defines the security parameter (number of iterations) of the NIZK
     proof (stage 1) which convince all verifiers that the TMCG key was
     correctly generated. The default value is `16' which implies a
     soundness error probability  \le d^-16, where d = \rm gcd(m,
     \phi(m)). This parameter is only relevant for the card encoding
     scheme of Schindelhauer.

 -- Macro: TMCG_KEY_NIZK_STAGE2
     Defines the security parameter (number of iterations) of the NIZK
     proof (stage 2) which convince all verifiers that the TMCG key was
     correctly generated. The default value is `128' which implies a
     soundness error probability  \le 2^-128.  This parameter is only
     relevant for the card encoding scheme of Schindelhauer.

 -- Macro: TMCG_KEY_NIZK_STAGE3
     Defines the security parameter (number of iterations) of the NIZK
     proof (stage 3) which convince all verifiers that the TMCG key was
     correctly generated. The default value is `128' which implies a
     soundness error probability  \le 2^-128.  This parameter is only
     relevant for the card encoding scheme of Schindelhauer.

 -- Macro: TMCG_LIBGCRYPT_VERSION
     Defines the required minimum version number of the GNU Crypto
     Library.  The default value is `"1.2.0"'. During the
     initialization of LibTMCG (see `init_libTMCG') it is checked,
     whether the version number of the linked shared object fulfills
     this condition.

 -- Macro: TMCG_LIBGMP_VERSION
     Defines the required minimum version number of the GNU Multiple
     Precision Arithmetic Library. The default value is `"4.1.0"'.
     During the initialization of LibTMCG (see `init_libTMCG') it is
     checked, whether the version number provided by the header file
     `gmp.h' and used at compile time of LibTMCG fulfills this
     condition.

 -- Macro: TMCG_MAX_CARDS
     Defines the maximum number of stackable cards.  The default value
     is `128'.

 -- Macro: TMCG_MAX_PLAYERS
     Defines the maximum number of players.  The default value is `32'.
     This parameter is only relevant for the card encoding scheme of
     Schindelhauer.

 -- Macro: TMCG_MAX_TYPEBITS
     Defines the maximum number of bits to represent the card type in
     the scheme of Schindelhauer. On the other hand, this value
     determines the maximum size of the message space in the scheme of
     Barnett and Smart. The default value is `8' which implies that 256
     different card types are possible.

 -- Macro: TMCG_MPZ_IO_BASE
     Defines the input and output base of the `std::iostream' operators
     `<<' and `>>' which are used to encode large integers (`mpz_t').
     The default value is `36' which is currently the largest base
     supported by the GNU Multiple Precision Arithmetic Library.

 -- Macro: TMCG_PRAB_K0
     Defines the security parameter k_0 (in characters) of the PRab
     scheme (see Bellare, Rogaway: _The Exact Security of Digital
     Signatures - How to Sign with RSA and Rabin_, 1996). The default
     value is `20' which implies a security level around 2^80.

 -- Macro: TMCG_QRA_SIZE
     Defines the security parameter (size of the modulus m = p \cdot q
     in bit) of the TMCG key. The underlying assumptions are QRA and
     FACTOR.  The default value is `1024'. This parameter is only
     relevant for TMCG keys and Schindelhauer's encoding scheme.

 -- Macro: TMCG_SAEP_S0
     Defines the security parameter s_0 (in characters) of the
     Rabin-SAEP scheme (see Boneh: _Simplified OAEP for the RSA and
     Rabin Functions_, 2002). The default value is `20' which implies a
     security around 2^80 against CCA (Chosen Ciphertext Attacks).

 -- Macro: TMCG_HASH_COMMITMENT
     Defines whether shortened commitments are used in the shuffle
     verification procedure of Schindelhauer. The default value is
     `true', because it will decrease the communication complexity
     significantly. However, as an immediate consequence the soundness
     property is violated, if the used hash function
     `TMCG_GCRY_MD_ALGO' is broken.

 -- Macro: TMCG_MAX_FPOWM_T
     Defines the maximum size of admissible exponents (in bit) used by
     fast exponentiation procedures. The default value is `2048'. Note
     that this parameter has a strong influence on the amount of memory
     allocated by LibTMCG since it determines the size of the
     precomputed tables.  However, it should be at least greater than
     `TMCG_DDH_SIZE' and `TMCG_QRA_SIZE'.

   ---------- Footnotes ----------

   (1) This is a constant defined by the GNU Crypto Library.


File: libTMCG.info,  Node: Data Types and Classes,  Prev: Preprocessor Defined Global Symbols,  Up: Application Programming Interface

2.2 Data Types and Classes
==========================

This section describes all public data types and classes that are
necessary to create a secure card game. Private methods and only
internally used members are not explained.

* Menu:

* Data Types::
* Classes::


File: libTMCG.info,  Node: Data Types,  Next: Classes,  Up: Data Types and Classes

2.2.1 Data Types
----------------

LibTMCG provides several data structures for cards, stacks, and
cryptographic keys.

2.2.1.1 Encoding Schemes for Cards
..................................

There exist two different encoding schemes that can be used for the
digital representation of playing cards. In the scheme of
Schindelhauer [Sc98] the type of a card is shared among the players
through bit-wise representation by quadratic (non-)residues. Thus the
security relies on the well-known QRA (Quadratic Residuosity
Assumption).  Unfortunately, the size of a card grows linearly in the
number of players and logarithmically in the number of card types.
Recently the much more efficient solution of Barnett and Smart [BS03]
has been implemented. This encoding works on a cyclic group of prime
order and requires that the DDH (Decisional Diffie-Hellman Assumption)
holds there.

   For both schemes LibTMCG provides a structure whose name contains the
suffix `Card'. This data type is used to represent an open or even a
masked card. Further, there is a corresponding structure whose name
contains the suffix `CardSecret'. This data type is used to represent
the secret values involved in a card masking operation.

   Because of the reduced computational and communication complexity
(see [St05] for details) the usage of the second card encoding scheme,
i.e. `VTMF_Card' and `VTMF_CardSecret', is highly recommended.

 -- Data type: TMCG_Card
     	This `struct' represents a card in the encoding scheme 	of
     Schindelhauer [Sc98]. The type of the card is shared 	among
     the players by quadratic residues and non-residues,
     respectively. Thus the security relies on the Quadratic
     Residuosity Assumption.



      -- Member of TMCG_Card: std::vector< std::vector<MP_INT> > z
          		This k\times w-matrix encodes the type of the
          corresponding card in a shared way. For each of the
          k players there is a separate row and for each of
          the w bits in the binary representation of the
          type there is a column. The elements are numbers from
          the group \bf Z^\circ_m_i where m_i 		is the public
          modulus of the ith player.



      -- Constructor on TMCG_Card: TMCG_Card ()
          		This default constructor initializes the card
          with an empty 		1\times 1-matrix. Later the
          method 		`TMCG_Card::resize' can be used to
          enlarge the 		card representation.



      -- Constructor on TMCG_Card: TMCG_Card (`size_t' k, `size_t' w)
          		This constructor initializes the card with an
          empty 		k\times w-matrix. The parameter K is the
          number of players and W is the maximum number
          of bits used by the binary representation of the card
          type.



      -- Constructor on TMCG_Card:  TMCG_Card (`const TMCG_Card&' that)
          		This is a simple copy-constructor and THAT is
          the card to be 		copied.



      -- Operator on TMCG_Card: TMCG_Card& = (`const TMCG_Card&' that)
          		This is a simple assignment-operator and THAT
          is the card to 		be assigned.



      -- Operator on TMCG_Card: bool == (`const TMCG_Card&' that)
          		This operator tests two card representations
          for equality.



      -- Operator on TMCG_Card: bool != (`const TMCG_Card&' that)
          		This operator tests two card representations
          for inequality.



      -- Method on TMCG_Card: void resize (`size_t' k, `size_t' w)
          		This method resizes the representation of the
          card.  		The current content of the member `z'
          will be 		released and a new k\times w-matrix is
          created.  		The parameter K is the number of
          players and 		W is the maximum number of bits used by
          the binary 		representation of the card type.



      -- Method on TMCG_Card: bool import (`std::string' s)
          		This method imports the content of the member
          `z' from 		the correctly formatted input string S.
          It returns 		`true', if the import was successful.



      -- Destructor on TMCG_Card: ~TMCG_Card ()
          		This destructor releases all occupied resources.

 -- Operator on TMCG_Card: std::ostream& << (`std::ostream&' out,
          `const TMCG_Card&' card)
     	This operator exports the content of the member `z' 	(of the
     given `TMCG_Card' CARD) to the output 	stream OUT.

 -- Operator on TMCG_Card: std::istream& >> (`std::istream&' in,
          `TMCG_Card&' card)
     	This operator imports the content of the member `z' 	(of the
     given `TMCG_Card' CARD) from the input 	stream IN. The data has
     to be delimited by a newline 	character. The `failbit' of the
     stream is set, if any 	parse error occurred.

 -- Data type: TMCG_CardSecret
     	This `struct' represents the secret used for a card masking
     operation in the original encoding scheme of Schindelhauer [Sc98].



      -- Member of TMCG_CardSecret: std::vector< std::vector<MP_INT> > r
          		This k\times w-matrix encodes the first part of
          the 		secret. For each of the k players there is a
          separate 		row and for each of the w bits in the
          binary representation 		of the corresponding
          card type there is a column. The elements are
          numbers from the group \bf Z^\circ_m_i where m_i
          is the public modulus of the ith player.



      -- Member of TMCG_CardSecret: std::vector< std::vector<MP_INT> > b
          		This k\times w-matrix encodes the second part
          of the 		secret. For each of the k players there
          is a separate 		row and for each of the w bits
          in the binary representation 		of the corresponding
          card type there is a column. The elements are
          simply numbers from \0, 1\.



      -- Constructor on TMCG_CardSecret: TMCG_CardSecret ()
          		This default constructor initializes both
          members with an empty 		1\times 1-matrix. Later
          the method 		`TMCG_CardSecret::resize' can be used
          to enlarge the 		card representation.



      -- Constructor on TMCG_CardSecret: TMCG_CardSecret (`size_t' k,
               `size_t' w)
          		This constructor initializes both members with
          an empty 		k\times w-matrix. The parameter K is the
          number of players and W is the maximum number
          of bits used by the binary representation of the
          corresponding card type.



      -- Constructor on TMCG_CardSecret:  TMCG_CardSecret (`const
               TMCG_CardSecret&' that)
          		This is a simple copy-constructor and THAT is
          the secret to be 		copied.



      -- Operator on TMCG_CardSecret: TMCG_CardSecret& = (`const
               TMCG_CardSecret&' that)
          		This is a simple assignment-operator and THAT
          is the secret to 		be assigned.



      -- Method on TMCG_CardSecret: void resize (`size_t' k, `size_t' w)
          		This method resizes the representation of the
          secret.  		The current content of the members `r'
          and `b' 		will be released and new k\times
          w-matrices are 		created. The parameter K is the
          number of players and 		W is the maximum number
          of bits used by the binary 		representation of the
          corresponding card type.



      -- Method on TMCG_CardSecret: bool import (`std::string' s)
          		This method imports the content of the members
          `r' and 		`b' from the correctly formatted input
          string S.  		It returns `true', if the import was
          successful.



      -- Destructor on TMCG_CardSecret: ~TMCG_CardSecret ()
          		This destructor releases all occupied resources.

 -- Operator on TMCG_CardSecret: std::ostream& << (`std::ostream&' out,
          `const TMCG_CardSecret&' cardsecret)
     	This operator exports the content of the members `r' 	and `b'
     (of the given `TMCG_CardSecret' 	CARDSECRET) to the output
     stream OUT.

 -- Operator on TMCG_CardSecret: std::istream& >> (`std::istream&' in,
          `TMCG_CardSecret&' cardsecret)
     	This operator imports the content of the members `r' 	and `b'
     (of the given `TMCG_CardSecret' 	CARDSECRET) from the input
     stream IN.  	The data has to be delimited by a newline
     character.  	The `failbit' of the stream is set, if any
     parse error 	occurred.

 -- Data type: VTMF_Card
     	This `struct' represents a card in the encoding scheme 	of
     Barnett and Smart [BS03]. Here we use the discrete logarithm
     based instantiation of their general cryptographic primitive
     VTMF (Verifiable @var{k}-out-of-@var{k} Threshold Masking
     Function). The security relies on the DDH assumption in the
     underlying abelian group G.



      -- Member of VTMF_Card: mpz_t c_1
          		This is the first part of the encrypted card
          type.  		It is an element from the underlying
          group G.



      -- Member of VTMF_Card: mpz_t c_2
          		This is the second part of the encrypted card
          type.  		It is also an element from the
          underlying group G.



      -- Constructor on VTMF_Card: VTMF_Card ()
          		This default constructor initializes an empty
          card where 		the members `c_1' and `c_2' are set to
          zero.



      -- Constructor on VTMF_Card:  VTMF_Card (`const VTMF_Card&' that)
          		This is a simple copy-constructor and THAT is
          the 		card to be copied.



      -- Operator on VTMF_Card: VTMF_Card& = (`const VTMF_Card&' that)
          		This is a simple assignment-operator and THAT is
          the card to be assigned.



      -- Operator on VTMF_Card: bool == (`const VTMF_Card&' that)
          		This operator tests two card representations
          for equality.



      -- Operator on VTMF_Card: bool != (`const VTMF_Card&' that)
          		This operator tests two card representations
          for inequality.



      -- Method on VTMF_Card: bool import (`std::string' s)
          		This method imports the content of the members
          `c_1' 		and `c_2' from a correctly formatted
          input string 		S. It returns `true', if the import was
          successful.



      -- Destructor on VTMF_Card: ~VTMF_Card ()
          		This destructor releases all occupied resources.

 -- Operator on VTMF_Card: std::ostream& << (`std::ostream&' out,
          `const VTMF_Card&' card)
     	This operator exports the content of the members `c_1' 	and
     `c_2' (of the given `VTMF_Card' CARD) 	to the output stream
     OUT.

 -- Operator on VTMF_Card: std::istream& >> (`std::istream&' in,
          `VTMF_Card&' card)
     	This operator imports the content of the members `c_1' 	and
     `c_2' (of the given `VTMF_Card' CARD) 	from the input stream
     IN. The data has to be delimited 	by a newline character. The
     `failbit' of the stream is 	set, if any parse error
     occurred.

 -- Data type: VTMF_CardSecret
     	This `struct' represents the secrets used in the card masking
     operation by the encoding scheme of Barnett and Smart [BS03].



      -- Member of VTMF_CardSecret: mpz_t r
          		This member is the exponent (randomizer) used
          in the masking operation.  		It should be chosen
          uniformly and randomly from \bf Z_q 		where q is the
          order of the finite abelian group G 		for which the
          DDH assumption holds.

          		According to the results of Koshiba and
          Kurosawa (see _Short Exponent 		Diffie-Hellman
          Problems_, PKC 2004, LNCS 2947) the length of
          this exponent can be shorten to a more efficient size (e.g.
          160 bit), 		if the corresponding generator of G is
          adjusted as well. Under the 		additional DLSE
          (Discrete Logarithm with Short Exponents)
          assumption the DDH problem in G seems to be still hard.
          By such an optimization trick we gain a great performance
          advantage for 		almost all modular
          exponentiations that are computed during the masking
          operation, if the VTMF primitive was instantiated by the
          later explained 		class
          `BarnettSmartVTMF_dlog_GroupQR'. Furthermore, the size of the
          card secret is substantially reduced which results in an
          improved 		communication complexity.



      -- Constructor on VTMF_CardSecret: VTMF_CardSecret ()
          		This default constructor initializes the secret
          with an 		empty member `r'.



      -- Constructor on VTMF_CardSecret:  VTMF_CardSecret (`const
               VTMF_CardSecret&' that)
          		This is a simple copy-constructor and THAT is
          the secret to be 		copied.



      -- Operator on VTMF_CardSecret: VTMF_CardSecret& = (`const
               VTMF_CardSecret&' that)
          		This is a simple assignment-operator and THAT
          is the secret to 		be assigned.



      -- Method on VTMF_CardSecret: bool import (`std::string' s)
          		This method imports the content of the member
          `r' 		from the correctly formatted input string S.
          It returns `true', if the import was successful.



      -- Destructor on VTMF_CardSecret: ~VTMF_CardSecret ()
          		This destructor releases all occupied resources.

 -- Operator on VTMF_CardSecret: std::ostream& << (`std::ostream&' out,
          `const VTMF_CardSecret&' cardsecret)
     	This operator exports the content of the member `r' 	(of the
     given `VTMF_CardSecret' CARDSECRET) 	to the output stream
     OUT.

 -- Operator on VTMF_CardSecret: std::istream& >> (`std::istream&' in,
          `VTMF_CardSecret&' cardsecret)
     	This operator imports the content of the member `r' 	(of the
     given `VTMF_CardSecret' CARDSECRET) 	from the input stream
     IN. The data has to be 	delimited by a newline character. The
     `failbit' of 	the stream is set, if any parse error occurred.

2.2.1.2 Stacks
..............

All of the following data types are generic containers that can be
instantiated as C++ templates with the former explained `Card' and
`CardSecret' data types, respectively. Note the maximum number of
stackable data is upper-bounded by `TMCG_MAX_CARDS'.  There is no error
reported, if this limit is exceeded.

 -- Data type: TMCG_Stack<CARDTYPE>
     	This `struct' is a simple container for cards of the specified
     `CARDTYPE'. Currently, the elements can be either of type
     `TMCG_Card' or `VTMF_Card' depending on which kind of encoding
     scheme is used. The `TMCG_Stack' structure is mainly used to
     represent 	a stack of masked cards, i.e., playing cards that are
     stacked in a face-down 	manner. It can be either a public stack
     where all participants have access to 	or even a private
     stack, e.g. the players' hand. If the corresponding 	card
     types are known it can also serve as an "open stack", although
     `TMCG_OpenStack' is more suitable in that case.



      -- Member of TMCG_Stack: std::vector<CARDTYPE> stack
          		This is the container that is used internally
          for storing the cards.



      -- Constructor on TMCG_Stack: TMCG_Stack ()
          		This default constructor initializes an empty
          stack.



      -- Operator on TMCG_Stack: TMCG_Stack& = (`const
               TMCG_Stack<CARDTYPE>&' that)
          		This is a simple assignment-operator and THAT
          is the stack to 		be assigned.



      -- Operator on TMCG_Stack: bool == (`const TMCG_Stack<CARDTYPE>&'
               that)
          		This operator tests two stacks for equality. It
          checks whether the 		sizes of the stacks and the
          contained cards are equal with respect to 		the
          implied order.



      -- Operator on TMCG_Stack: bool != (`const TMCG_Stack<CARDTYPE>&'
               that)
          		This operator tests two stacks for inequality.
          It returns `true', if 		either the sizes does
          not match or at least two corresponding cards are
          not equal.



      -- Operator on TMCG_Stack: const CARDTYPE& [] (`size_t' n)
          		This operator provides read-only random access
          to the contained cards.  		It returns a
          const-reference to the Nth card from the top of the stack.



      -- Operator on TMCG_Stack: CARDTYPE& [] (`size_t' n)
          		This operator provides random access to the
          contained cards.  		It returns a reference to the
          Nth card from the top of the stack.



      -- Method on TMCG_Stack: size_t size ()
          		This method returns the size of the stack.



      -- Method on TMCG_Stack: void push (`const CARDTYPE&' c)
          		This method pushes the card C to the back of
          the stack.



      -- Method on TMCG_Stack: void push (`const TMCG_Stack<CARDTYPE>&'
               s)
          		This method pushes the stack S to the back of
          the stack.



      -- Method on TMCG_Stack: void push (`const
               TMCG_OpenStack<CARDTYPE>&' s)
          		This method pushes the cards of the open stack
          S to the back 		of the stack.



      -- Method on TMCG_Stack: bool empty ()
          		This method returns `true', if the stack is
          empty.



      -- Method on TMCG_Stack: bool pop (`CARDTYPE&' c)
          		This method removes a card from the back and
          stores the data in C.  		It returns `true', if
          the stack was not empty and thus C 		contains useful
          data.



      -- Method on TMCG_Stack: void clear ()
          		This method clears the stack, i.e., it removes
          all cards.



      -- Method on TMCG_Stack: bool find (`const CARDTYPE&' c)
          		This method returns `true', if the card C was
          found in the 		stack.



      -- Method on TMCG_Stack: bool remove (`const CARDTYPE&' c)
          		This method removes the top-most card from the
          stack which is equal to 		C. It returns `true',
          if the card was found and successfully 		removed.



      -- Method on TMCG_Stack: size_t removeAll (`const CARDTYPE&' c)
          		This method removes every card from the stack
          which is equal to C.  		It returns the number
          of removed cards.



      -- Method on TMCG_Stack: bool import (`std::string' s)
          		This method imports the stack from the
          correctly formatted input string 		S. It returns
          `true', if the import was successful.



      -- Destructor on TMCG_Stack: ~TMCG_Stack ()
          		This destructor releases all occupied resources.

 -- Operator on TMCG_Stack: std::ostream& << (`std::ostream&' out,
          `const TMCG_Stack<CARDTYPE>&' stack)
     	This operator exports the given STACK to the output stream OUT.

 -- Operator on TMCG_Stack: std::istream& >> (`std::istream&' in,
          `TMCG_Stack<CARDTYPE>&' stack)
     	This operator imports the given STACK from the input stream IN.
     The data has to be delimited by a newline character. The `failbit'
     of 	the stream is set, if any parse error occurred.

 -- Data type: TMCG_OpenStack<CARDTYPE>
     	This `struct' is a simple container for cards of the specified
     `CARDTYPE' whose types are known. The elements are pairs where
     the first component is the type and the second component is the
     corresponding 	card. The card type is represented by a
     `size_t' integer. Currently, the 	cards can be either of type
     `TMCG_Card' or `VTMF_Card' depending on 	which kind of encoding
     scheme is used.



      -- Member of TMCG_OpenStack: std::vector<std::pair<size_t,
     CARDTYPE> > stack
          		This is the container that is used internally
          for storing the pairs.



      -- Constructor on TMCG_OpenStack: TMCG_OpenStack ()
          		This default constructor initializes an empty
          stack.



      -- Operator on TMCG_OpenStack: TMCG_OpenStack& = (`const
               TMCG_OpenStack<CARDTYPE>&' that)
          		This is a simple assignment-operator and THAT
          is the stack to 		be assigned.



      -- Operator on TMCG_OpenStack: bool == (`const
               TMCG_OpenStack<CARDTYPE>&' that)
          		This operator tests two stacks for equality. It
          checks whether the types, 		the sizes, and the
          contained cards are equal with respect to the stack order.



      -- Operator on TMCG_OpenStack: bool != (`const
               TMCG_OpenStack<CARDTYPE>&' that)
          		This operator tests two stacks for inequality.
          It returns `true', if 		either the sizes resp.
          types does not match or at least two corresponding cards
          are not equal.



      -- Operator on TMCG_OpenStack: const std::pair<size_t, CARDTYPE>&
     [] (`size_t' n)
          		This operator provides read-only random access
          to the contained pairs.  		It returns a
          const-reference to the Nth pair from the top of the stack.



      -- Operator on TMCG_OpenStack: std::pair<size_t, CARDTYPE>& []
               (`size_t' n)
          		This operator provides random access to the
          contained pairs.  		It returns a reference to the
          Nth pair from the top of the stack.



      -- Method on TMCG_OpenStack: size_t size ()
          		This method returns the size of the stack.



      -- Method on TMCG_OpenStack: void push (`const std::pair<size_t,
               CARDTYPE>&' p)
          		This method pushes the pair P to the back of
          the stack. The first 		component is the type and the
          second component is the corresponding card
          representation.



      -- Method on TMCG_OpenStack: void push (`size_t' type, `const
               CARDTYPE&' c)
          		This method pushes a pair to the back of the
          stack. The parameter TYPE 		is the card type and C
          is the corresponding card representation.



      -- Method on TMCG_OpenStack: void push (`const
               TMCG_OpenStack<CARDTYPE>&' s)
          		This method pushes the pairs of the stack S to
          the back 		of this stack.



      -- Method on TMCG_OpenStack: bool empty ()
          		This method returns `true', if the stack is
          empty.



      -- Method on TMCG_OpenStack: bool pop (`size_t&' type,
               `CARDTYPE&' c)
          		This method removes a pair from the back of the
          stack. It stores the card type 		in TYPE and
          the	representation in C. It returns `true', if the stack
          was not empty and thus TYPE and C contain useful data.



      -- Method on TMCG_OpenStack: void clear ()
          		This method clears the stack, i.e., it removes
          all pairs.



      -- Method on TMCG_OpenStack: bool find (`size_t' type)
          		This method returns `true', if a pair with the
          first component TYPE was 		found in the stack.



      -- Method on TMCG_OpenStack: bool remove (`size_t' type)
          		This method removes the top-most pair with the
          first component TYPE from the 		stack. It
          returns `true', if such a pair was found and successfully
          removed.



      -- Method on TMCG_OpenStack: size_t removeAll (`size_t' type)
          		This method removes every pair from the stack
          whose first component is equal to 		TYPE. Further
          it returns the number of removed pairs.



      -- Method on TMCG_OpenStack: bool move (`size_t' type,
               `TMCG_Stack<CARDTYPE>&' s)
          	This method moves the top-most card representation of
          the given TYPE to another 	stack S. It returns `true', if
          such a pair was found and successfully moved.



      -- Destructor on TMCG_OpenStack: ~TMCG_OpenStack ()
          		This destructor releases all occupied resources.

 -- Data type: TMCG_StackSecret<CARDSECRETTYPE>
     	This `struct' is a simple container for the secrets involved
     in the masking operation of cards. Additionally, the permutation
     of a corresponding shuffle of the stack is stored.  	The
     elements are pairs where the first component is a permutation
     index of type `size_t' and the second component is a card 	secret
     of the specified `CARDSECRETTYPE'. Currently, 	such secrets
     can be either of type `TMCG_CardSecret' or
     `VTMF_CardSecret' depending on which kind of encoding scheme
     is used.



      -- Member of TMCG_StackSecret: std::vector<std::pair<size_t,
     CARDSECRETTYPE> > stack
          		This is the container that is used internally
          for storing the pairs.



      -- Constructor on TMCG_StackSecret: TMCG_StackSecret ()
          		This default constructor initializes an empty
          stack secret.



      -- Operator on TMCG_StackSecret: TMCG_StackSecret& = (`const
               TMCG_StackSecret<CARDSECRETTYPE>&' that)
          		This is a simple assignment-operator and THAT
          is the 		stack secret to be assigned.



      -- Operator on TMCG_StackSecret: const std::pair<size_t,
     CARDSECRETTYPE>& [] (`size_t' n)
          		This operator provides read-only random access
          to the contained pairs.  		It returns a
          const-reference to the Nth pair from the top of the stack
          secret.



      -- Operator on TMCG_StackSecret: std::pair<size_t,
     CARDSECRETTYPE>& [] (`size_t' n)
          		This operator provides random access to the
          contained pairs.  		It returns a reference to the
          Nth pair from the top of the stack secret.



      -- Method on TMCG_StackSecret: size_t size ()
          		This method returns the size of the stack
          secret.



      -- Method on TMCG_StackSecret: void push (`size_t' index, `const
               CARDSECRETTYPE&' cs)
          		This method pushes a pair to the back of the
          stack secret. The parameter INDEX 		is the
          permutation index and CS is the corresponding card secret.



      -- Method on TMCG_StackSecret: void clear ()
          		This method clears the stack secret, i.e., it
          removes all pairs.



      -- Method on TMCG_StackSecret: size_t find_position (`size_t'
               index)
          		This method searches for a given permutation
          index in the stack secret.  		It returns the
          corresponding position(1) in 		the stack secret, if
          the INDEX was found. Otherwise, the size of 		the
          stack secret is returned. Please note that in this case the
          returned 		value is not a valid position for an
          access to the stack secret.



      -- Method on TMCG_StackSecret: bool find (`size_t' index)
          		This method searches for a given permutation
          index in the stack secret.  		It returns `true', if
          such an INDEX was found.



      -- Method on TMCG_StackSecret: bool import (`std::string' s)
          		This method imports the stack secret from a
          correctly formatted input string 		S. It returns
          `true', if the import was successful.



      -- Destructor on TMCG_StackSecret: ~TMCG_StackSecret ()
          		This destructor releases all occupied resources.

 -- Operator on TMCG_StackSecret: std::ostream& << (`std::ostream&'
          out, `const TMCG_StackSecret<CARDSECRETTYPE>&' stacksecret)
     	This operator exports the given STACKSECRET to the output
     stream OUT.

 -- Operator on TMCG_StackSecret: std::istream& >> (`std::istream&' in,
          `TMCG_StackSecret<CARDSECRETTYPE>&' stacksecret)
     	This operator imports the given STACKSECRET from the input
     stream IN.  	The data has to be delimited by a newline
     character. The `failbit' of 	the stream is set, if any parse
     error occurred.

2.2.1.3 Cryptographic Keys
..........................

LibTMCG only provides corresponding data types for keys used by the
encoding scheme of Schindelhauer [Sc98], because it is not efficient to
perform the key generation in every new game session. Furthermore, in
general you can encrypt and sign messages to ensure confidentiality and
integrity, even if the scheme of Barnett and Smart [BS03] has been
applied for the card encoding. Therefore these structures may be of
independent interest, for example to establish authenticated
communication channels between players.  However, like for all public
key cryptosystems a trusted PKI (Public Key Infrastructure) is needed.
This might not be a serious requirement in distributed game
environments, because the players can compare their key fingerprints by
telephone or a service provider can issue public key certificates.

 -- Data type: TMCG_SecretKey
     	This `struct' represents the secret part of the TMCG key. The
     underlying public key cryptosystem is due to Rabin with minor
     modifications for encryption padding (SAEP scheme 	of Boneh) and
     digital signatures (PRab scheme of Bellare and Rogaway).



      -- Member of TMCG_SecretKey: std::string name
          		This string contains the name or a pseudonym of
          the key owner.



      -- Member of TMCG_SecretKey: std::string email
          		This string contains the email address of the
          key owner.



      -- Member of TMCG_SecretKey: std::string type
          		This string contains information about the key
          type. The common 		prefix is `TMCG/RABIN'. It is
          followed by the decimal encoded 		bit size of the
          modulus m. The suffix `NIZK' signals 		that the
          correctness of the key is shown by an appended non-interactive
          zero-knowledge proof. The single parts are separated by
          underscore 		characters `_', e.g.,
          `TMCG/RABIN_1024_NIZK' has the correct 		form.
          However, the suffix can be left empty, if the key is
          only used for encryption and signing (non-NIZK key).



      -- Member of TMCG_SecretKey: std::string nizk
          		This string contains two stages of the
          non-interactive zero-knowledge 		proof of
          Gennaro, Micciancio, and Rabin (_An Efficient Non-Interactive
          Statistical Zero-Knowledge Proof System for Quasi-Safe Prime
          Products_, 		ACM CCS 1998). The proof shows that m
          was correctly 		generated as product of two
          primes both congruent to 3 (modulo 4).  		Further
          there is another non-interactive zero-knowledge proof appended
          which shows that the condition y\in\bf NQR^\circ_m holds.



      -- Member of TMCG_SecretKey: std::string sig
          		This string contains the self signature of the
          public key.



      -- Member of TMCG_SecretKey: mpz_t m
          		This is the public modulus m = p \cdot q which
          is the product 		of two secret primes p and q.
          The size of m 		is determined by the security
          parameter `TMCG_QRA_SIZE'.



      -- Member of TMCG_SecretKey: mpz_t y
          		This is the public quadratic non-residue y\in
          \bf NQR^\circ_m 		which is used in several
          zero-knowledge proofs of Schindelhauer's
          encoding scheme [Sc98].



      -- Member of TMCG_SecretKey: mpz_t p
          		This is the secret prime number p which is a
          factor of the 		modulus m.



      -- Member of TMCG_SecretKey: mpz_t q
          		This is the secret prime number q which is a
          factor of the 		modulus m.



      -- Constructor on TMCG_SecretKey: TMCG_SecretKey ()
          		This default constructor initializes an empty
          secret key.



      -- Constructor on TMCG_SecretKey:  TMCG_SecretKey (`const
               std::string&' n, `const std::string&' e, `unsigned long
               int' keysize `=TMCG_QRA_SIZE', `bool' nizk_key `=true')
          		This constructor generates a new secret key
          where N is the name or a 		pseudonym of the owner,
          E is a corresponding email address, 		KEYSIZE is the
          desired bit length of the modulus m, and NIZK_KEY indicates
          whether or not a NIZK proof will be appended. The
          default value of the third argument is set to `TMCG_QRA_SIZE',
          if KEYSIZE is omitted in the call. The default value of the
          fourth argument is set to `true', whenever it is omitted in
          the call. Depending on KEYSIZE and NIZK_KEY 		the
          generation is a very time-consuming task and dots are sent to
          `std::cerr' as a progress indicator.



      -- Constructor on TMCG_SecretKey:  TMCG_SecretKey (`const
               std::string&' s)
          		This constructor initializes the key from a
          correctly formatted 		input string S.



      -- Constructor on TMCG_SecretKey:  TMCG_SecretKey (`const
               TMCG_SecretKey&' that)
          		This is a simple copy-constructor and THAT is
          the key to be copied.



      -- Operator on TMCG_SecretKey: TMCG_SecretKey& = (`const
               TMCG_SecretKey&' that)
          		This is a simple assignment-operator and THAT
          is the key to be assigned.



      -- Method on TMCG_SecretKey: bool check ()
          		This method tests whether the self signature is
          valid and whether the 		non-interactive
          zero-knowledge proofs are sound. It returns `true',
          if all checks have been successfully passed. Due to the
          computational 		complexity of the verification
          procedure these checks are extremely 		time-consuming.



      -- Method on TMCG_SecretKey: std::string fingerprint ()
          		This method returns the fingerprint of the key.
          The fingerprint is the 		hexadecimal notation of
          the hash value (algorithm `TMCG_GCRY_MD_ALGO')
          on the members `name', `email', `type', `m', `y',
          `nizk', and `sig'.



      -- Method on TMCG_SecretKey: std::string selfid ()
          		This method returns the real value of the self
          signature. The string 		`ERROR' is returned, if
          any parse error occurred. The string
          `SELFSIG-SELFSIG-SELFSIG-SELFSIG-SELFSIG-SELFSIG' is returned,
          if the self signature `sig' was empty.



      -- Method on TMCG_SecretKey: std::string keyid (`size_t' size
               `=TMCG_KEYID_SIZE')
          		This method returns the unique key identifier
          of length SIZE.  		The default value of the first
          argument is set to `TMCG_KEYID_SIZE', 		if SIZE
          is omitted in the call.



      -- Method on TMCG_SecretKey: size_t keyid_size (`const
               std::string&' s)
          		This method returns the length of the unique
          key identifier S.  		Zero is returned, if any parse
          error occurred.



      -- Method on TMCG_SecretKey: std::string sigid (`std::string' s)
          		This method returns the unique key identifier
          which is included in the 		signature S. The string
          `ERROR' is returned, if any parse 		error occurred.



      -- Method on TMCG_SecretKey: bool import (`std::string' s)
          		This method imports the key from a correctly
          formatted input string 		S. It returns `true',
          if the import was successful.



      -- Method on TMCG_SecretKey: bool decrypt (`char*' value,
               `std::string' s)
          		This method decrypts the given encryption
          packet S and stores 		the content in VALUE which is a
          pointer to a character array 		of size `TMCG_SAEP_S0'.
          The method returns `true', if the 		decryption was
          successful.



      -- Method on TMCG_SecretKey: std::string sign (`const
               std::string&' data)
          		This method returns a digital signature on DATA.



      -- Method on TMCG_SecretKey: std::string encrypt (`const char*'
               value)
          		This method encrypts the content of VALUE which
          is a pointer to a 		character array of size
          `TMCG_SAEP_S0'. The method returns a 		corresponding
          encryption packet that can be decrypted by the owner of the
          secret key.



      -- Method on TMCG_SecretKey: bool verify (`const std::string&'
               data, `std::string' s)
          		This method verifies whether the signature S on
          DATA is valid 		or not. It returns `true', if
          everything was sound.



      -- Destructor on TMCG_SecretKey: ~TMCG_SecretKey ()
          		This destructor releases all occupied resources.

 -- Operator on TMCG_SecretKey: std::ostream& << (`std::ostream&' out,
          `const TMCG_SecretKey&' key)
     	This operator exports the given KEY to the output stream OUT.

 -- Operator on TMCG_SecretKey: std::istream& >> (`std::istream&' in,
          `TMCG_SecretKey&' key)
     	This operator imports the given KEY from the input stream IN.
     The data has to be delimited by a newline character. The `failbit'
     is set, if any parse error occurred.

 -- Data type: TMCG_PublicKey
     	This `struct' represents the public part of the TMCG key.



      -- Member of TMCG_PublicKey: std::string name
          		This string contains the name or a pseudonym of
          the key owner.



      -- Member of TMCG_PublicKey: std::string email
          		This string contains the email address of the
          key owner.



      -- Member of TMCG_PublicKey: std::string type
          		This string contains information about the key
          type. The common 		prefix is `TMCG/RABIN'. It is
          followed by the decimal encoded 		bit size of the
          modulus m. The suffix `NIZK' signals 		that the
          correctness of the key is shown by an appended non-interactive
          zero-knowledge proof. The single parts are separated by
          underscore 		characters `_', e.g.,
          `TMCG/RABIN_1024_NIZK' has the correct 		form.
          However, the suffix can be left empty, if the key is
          only used for encryption and signing.



      -- Member of TMCG_PublicKey: std::string nizk
          		This string contains two stages of
          non-interactive zero-knowledge 		proof of
          Gennaro, Micciancio and Rabin (ACM CCS, 1998). They show
          that the modulus m was correctly generated. Further there is
          another 		non-interactive zero-knowledge proof
          appended which shows that the condition 		y\in\bf
          NQR^\circ_m holds.



      -- Member of TMCG_PublicKey: std::string sig
          		This string contains the self signature of the
          public key.



      -- Member of TMCG_PublicKey: mpz_t m
          		This is the public modulus m = p \cdot q which
          is the product 		of two secret primes p and q.
          The size of m 		is determined by the security
          parameter `TMCG_QRA_SIZE'.



      -- Member of TMCG_PublicKey: mpz_t y
          		This is the public quadratic non-residue y\in
          \bf NQR^\circ_m 		which is used by several
          zero-knowledge proofs of the toolbox.



      -- Constructor on TMCG_PublicKey: TMCG_PublicKey ()
          		This default constructor initializes an empty
          public key.



      -- Constructor on TMCG_PublicKey:  TMCG_PublicKey (`const
               TMCG_SecretKey&' skey)
          		This constructor initializes the key using
          public values 		of the secret key SKEY.



      -- Constructor on TMCG_PublicKey:  TMCG_PublicKey (`const
               TMCG_PublicKey&' pkey)
          		This is a simple copy-constructor and PKEY is
          the key to be copied.



      -- Operator on TMCG_PublicKey: TMCG_PublicKey& = (`const
               TMCG_PublicKey&' that)
          		This is a simple assignment-operator and THAT
          is the key to be assigned.



      -- Method on TMCG_PublicKey: bool check ()
          		This method tests whether the self signature is
          valid and whether the 		non-interactive
          zero-knowledge proofs are sound. It returns `true',
          if all checks have been successfully passed. Due to the
          computational 		complexity of the verification
          procedure these checks are extremely 		time-consuming.



      -- Method on TMCG_PublicKey: std::string fingerprint ()
          		This method returns the fingerprint of the key.
          The fingerprint is the 		hexadecimal notation of
          the hash value (algorithm `TMCG_GCRY_MD_ALGO')
          on the members `name', `email', `type', `m', `y',
          `nizk', and `sig'.



      -- Method on TMCG_PublicKey: std::string selfid ()
          		This method returns the real value of the self
          signature. The string 		`ERROR' is returned, if
          any parse error occurred. The string
          `SELFSIG-SELFSIG-SELFSIG-SELFSIG-SELFSIG-SELFSIG' is returned,
          if the self signature `sig' was empty.



      -- Method on TMCG_PublicKey: std::string keyid (`size_t' size
               `=TMCG_KEYID_SIZE')
          		This method returns the unique key identifier
          of length SIZE.  		The default value of the first
          argument is set to `TMCG_KEYID_SIZE', 		if SIZE
          is omitted in the call.



      -- Method on TMCG_PublicKey: size_t keyid_size (`const
               std::string&' s)
          		This method returns the length of the unique
          key identifier S.  		Zero is returned, if any parse
          error occurred.



      -- Method on TMCG_PublicKey: std::string sigid (`std::string' s)
          		This method returns the unique key identifier
          which is included in the 		signature S. The string
          `ERROR' is returned, if any parse 		error occurred.



      -- Method on TMCG_PublicKey: bool import (`std::string' s)
          		This method imports the key from a correctly
          formatted input string 		S. It returns `true',
          if the import was successful.



      -- Method on TMCG_PublicKey: std::string encrypt (`const char*'
               value)
          		This method encrypts the content of VALUE which
          is a pointer to a 		character array of size
          `TMCG_SAEP_S0'. The method returns a 		corresponding
          encryption packet that can be decrypted by the owner of the
          secret key.



      -- Method on TMCG_PublicKey: bool verify (`const std::string&'
               data, `std::string' s)
          		This method verifies whether the signature S on
          DATA is valid 		or not. It returns `true', if
          everything was sound.



      -- Destructor on TMCG_PublicKey: ~TMCG_PublicKey ()
          		This destructor releases all occupied resources.

 -- Operator on TMCG_PublicKey: std::ostream& << (`std::ostream&' out,
          `const TMCG_PublicKey&' key)
     	This operator exports the given KEY to the output stream OUT.

 -- Operator on TMCG_PublicKey: std::istream& >> (`std::istream&' in,
          `TMCG_PublicKey&' key)
     	This operator imports the given KEY from the input stream IN.
     The data has to be delimited by a newline character. The `failbit'
     is set, if any parse error occurred.

 -- Data type: TMCG_PublicKeyRing
     	This `struct' is just a simple container for TMCG public keys.
     There are 	no particular methods provided by `TMCG_PublicKeyRing'.
     You have to use 	the regular interface of the STL container
     `std::vector' to access the 	single keys of the ring.



      -- Member of TMCG_PublicKeyRing: std::vector<TMCG_PublicKey> keys
          		This is the real container that is used to
          store the keys.



      -- Constructor on TMCG_PublicKeyRing: TMCG_PublicKeyRing ()
          		This default constructor initializes an empty
          public key ring.



      -- Constructor on TMCG_PublicKeyRing: TMCG_PublicKeyRing
               (`size_t' n)
          		This constructor initializes the container for
          storing exactly 		N keys.



      -- Destructor on TMCG_PublicKeyRing: ~TMCG_PublicKeyRing ()
          		This destructor releases all occupied resources.

   ---------- Footnotes ----------

   (1) According to the behavior 		of the `[]'-operator,
the zero denotes always the top-most position.


File: libTMCG.info,  Node: Classes,  Prev: Data Types,  Up: Data Types and Classes

2.2.2 Classes
-------------

LibTMCG consists of several C++ classes. Some of them are only
extensions or optimizations, but other provide necessary interfaces to
perform the basic operations in secure card games, e.g., the creation
of open cards, the masking of cards, the opening of masked cards, the
verifiable secret shuffle of a stack, and more general tasks like
distributed key generation procedures. Each class implements the main
functionality of the corresponding research paper [Sc98,BS03,Gr05]. The
author names are a prefix of the class name and the then following part
is an abbreviation of the title.

2.2.2.1 Verifiable K-out-of-K Threshold Masking Function
........................................................

The two classes of this subsection are concrete instantiations of
Barnett and Smart's VTMF primitive [BS03]. More formally, the authors
specify four different protocols:


   * Key Generation Protocol

   * Verifiable Masking Protocol

   * Verifiable Re-masking Protocol

   * Verifiable Decryption Protocol
   Each protocol uses low-level operations on an appropriately chosen
algebraic group G. The choice of this group is crucial to the security
of the card encoding scheme and thus to the high-level operations on
cards resp.  stacks.

   There are just a few methods and members of these classes that might
be of general interest for an application programmer, e.g. the methods
of the key generation protocol. The other stuff is only used internally
by high-level operations of `SchindelhauerTMCG'. Therefore this manual
omits the description of such internal functions and members.

 -- Class: BarnettSmartVTMF_dlog
     	This class implements the discrete logarithm instantiation of
     the VTMF 	primitive in the field \bf Z/p\bf Z, where p is a large
     prime number. The mathematical computations are performed in the
     finite cyclic 	subgroup G of prime order q such that p = kq +
     1 holds 	for some k\in \bf Z. The security relies on the DDH
     assumption in 	G, i.e., the distribution \g^a, g^b, g^ab\ is
     computationally 	indistinguishable from \g^a, g^b, g^c\, where g
     is a 	generator of G and a, b, c are chosen at random from
     \bf Z_q. Currently, this well-established assumption is believed to
     hold, if p and q are chosen according to the predefined security
     parameters of LibTMCG.



      -- Member of BarnettSmartVTMF_dlog: mpz_t p
          		This is the public prime number p which defines
          the 		underlying field \bf Z/p\bf Z.



      -- Member of BarnettSmartVTMF_dlog: mpz_t q
          		This is the public prime number q which defines
          the 		underlying cyclic group G. G is a subgroup of
          \bf Z/p\bf Z and is exactly of order q.



      -- Member of BarnettSmartVTMF_dlog: mpz_t g
          		This is the fixed public generator g of the
          underlying 		group G.



      -- Member of BarnettSmartVTMF_dlog: mpz_t k
          		This is a public integer k such that p = kq + 1
          holds.



      -- Member of BarnettSmartVTMF_dlog: mpz_t h
          		This is the common public key h = \prod_i=1^k
          h_i which contains 		the public keys h_i of each
          player P_i. Note that in the 		above formula k denotes
          the number of players.



      -- Constructor on BarnettSmartVTMF_dlog:  BarnettSmartVTMF_dlog
               (`unsigned long int' fieldsize `=TMCG_DDH_SIZE',
               `unsigned long int' subgroupsize `=TMCG_DLSE_SIZE')
          		This constructor creates a new VTMF instance.
          That means, the primes 		p and q are randomly
          and uniformly chosen such that 		they have
          length FIELDSIZE bit and SUBGROUPSIZE bit, respectively.
          Further, a generator g for the unique subgroup of order q is
          chosen at random. If the arguments are omitted, then
          FIELDSIZE and 		SUBGROUPSIZE are set to their
          default values `TMCG_DDH_SIZE' and
          `TMCG_DLSE_SIZE', respectively.  		Depending on
          FIELDSIZE and SUBGROUPSIZE the group generation
          is a very time-consuming task and some dots are sent to
          `std::cerr' as 		a progress indicator.



      -- Constructor on BarnettSmartVTMF_dlog:  BarnettSmartVTMF_dlog
               (`std::istream&' in, `unsigned long int' fieldsize
               `=TMCG_DDH_SIZE', `unsigned long int' subgroupsize
               `=TMCG_DLSE_SIZE')
          		This constructor initializes the VTMF instance
          from a correctly formatted 		input stream IN. For
          example, such a stream can be generated by calling
          the method `PublishGroup' of an already created instance. The
          arguments 		FIELDSIZE and SUBGROUPSIZE are stored
          for later following usage, 		e.g. by the method
          `CheckGroup' as explained below.  		If these
          arguments are omitted, then they are set to the default values
          `TMCG_DDH_SIZE' and `TMCG_DLSE_SIZE', respectively.



      -- Method on BarnettSmartVTMF_dlog: bool CheckGroup ()
          		This method checks whether p and q have
          appropriate sizes 		with respect to the bit lengths
          given during the initialization of the
          corresponding instance. Further, it checks whether p has the
          correct 		form (i.e. p = kq +1), whether p and q
          are probable 		prime, and whether g is a generator of
          the subgroup G. It 		returns `true', if all of these
          checks have been passed successfully.



      -- Method on BarnettSmartVTMF_dlog: void PublishGroup
               (`std::ostream&' out)
          		This method exports all necessary group
          parameters of G to 		the given output stream OUT, so
          other VTMF instances of G 		can be initialized,
          e.g. with the second constructor of
          `BarnettSmartVTMF_dlog'.



      -- Method on BarnettSmartVTMF_dlog: void
     KeyGenerationProtocol_GenerateKey ()
          		This method generates a VTMF key pair and
          stores the pair internally for 		a later
          following usage. It must be called before any other part
          of the key generation protocol is executed. Otherwise, the
          produced results 		are wrong.



      -- Method on BarnettSmartVTMF_dlog: void
     KeyGenerationProtocol_PublishKey (`std::ostream&' out)
          		This method exports the public part of the
          generated VTMF key pair to the 		given output
          stream OUT. Further, it appends a non-interactive
          zero-knowledge proof of knowledge which shows that the
          instance knows the 		secret part.  		Due to
          the non-interactive nature of this proof the method has to be
          called 		only once while the computed output can
          be reused multiple times if necessary.



      -- Method on BarnettSmartVTMF_dlog: bool
     KeyGenerationProtocol_UpdateKey (`std::istream&' in)
          		This method reads the public part of a VTMF key
          and the proof of knowledge 		from the input stream
          IN. It appends the key to the common public key
          and returns `true', if the given proof was sound. Otherwise,
          `false' 		is returned.



      -- Method on BarnettSmartVTMF_dlog: bool
     KeyGenerationProtocol_RemoveKey (`std::istream&' in)
          		This method reads the public part of a VTMF key
          and the corresponding proof 		of knowledge from the
          input stream IN. It removes the key from the 		common
          public key and returns `true', if the key was previously
          appended 		by `KeyGenerationProtocol_UpdateKey' as
          explained above.



      -- Method on BarnettSmartVTMF_dlog: void
     KeyGenerationProtocol_Finalize ()
          		This method must be called after any update
          (`KeyGenerationProtocol_UpdateKey') or removal
          (`KeyGenerationProtocol_RemoveKey') has been performed
          on the common public key.



      -- Destructor on BarnettSmartVTMF_dlog: ~BarnettSmartVTMF_dlog ()
          		This destructor releases all occupied resources.

 -- Subclass of `BarnettSmartVTMF_dlog': BarnettSmartVTMF_dlog_GroupQR
     	This subclass implements the discrete logarithm instantiation
     of the VTMF 	primitive in the field \bf Z/p\bf Z, where p is
     a large 	prime number. The mathematical computations are
     performed in the finite 	cyclic subgroup G (quadratic residues
     modulo p) of prime order 	q, where p = 2q + 1 holds. The security
     relies on the DDH 	assumption in G, i.e., the distribution \g^a,
     g^b, g^ab\ 	is computationally indistinguishable from \g^a,
     g^b, g^c\, where 	g is a generator of G and a, b, c are chosen at
     random 	from \bf Z_q. Currently, this well-established
     assumption is believed 	to hold, if p and q are chosen
     according to the predefined 	security parameters of LibTMCG.



      -- Member of BarnettSmartVTMF_dlog_GroupQR: mpz_t p
          		This is the public prime number p which defines
          the 		underlying field \bf Z/p\bf Z.



      -- Member of BarnettSmartVTMF_dlog_GroupQR: mpz_t q
          		This is the public prime number q which defines
          the 		underlying cyclic group G. G denotes the unique
          subgroup of quadratic residues modulo p which is
          exactly of order q, if p = 2q + 1 holds.



      -- Member of BarnettSmartVTMF_dlog_GroupQR: mpz_t g
          		This is the fixed public generator g of the
          underlying 		group G.



      -- Member of BarnettSmartVTMF_dlog_GroupQR: mpz_t k
          		This integer is fixed here by k = 2.



      -- Member of BarnettSmartVTMF_dlog_GroupQR: mpz_t h
          		This is the common public key h = \prod_i=1^k
          h_i which contains 		the public keys h_i of each
          player P_i. Note that in the 		above formula k denotes
          the number of players.



      --  on BarnettSmartVTMF_dlog_GroupQR:
     BarnettSmartVTMF_dlog_GroupQR (`unsigned long int' fieldsize
               `=TMCG_DDH_SIZE', `unsigned long int' exponentsize
               `=TMCG_DLSE_SIZE')
          		This constructor creates a new VTMF instance.
          That means, the safe prime 		p is randomly and
          uniformly chosen such that it has a length of
          FIELDSIZE bit.  		Further, the generator g is
          initially set up by 2 and then 		shifted by
          FIELDSIZE - EXPONENTSIZE bit positions,
          according to the procedure described by Koshiba and Kurosawa
          (see 		_Short Exponent Diffie-Hellman Problems_,
          PKC 2004, LNCS 2947).  		If the arguments of the
          constructor are omitted, then FIELDSIZE and
          EXPONENTSIZE are set to their default values `TMCG_DDH_SIZE'
          and 		`TMCG_DLSE_SIZE', respectively.
          Depending on FIELDSIZE and EXPONENTSIZE the group generation
          is a very time-consuming task and some dots are sent to
          `std::cerr' as 		a progress indicator.



      --  on BarnettSmartVTMF_dlog_GroupQR:
     BarnettSmartVTMF_dlog_GroupQR (`std::istream&' in, `unsigned long
               int' fieldsize `=TMCG_DDH_SIZE', `unsigned long int'
               exponentsize `=TMCG_DLSE_SIZE')
          		This constructor initializes the VTMF instance
          from a correctly formatted 		input stream IN. For
          example, such a stream can be generated by calling
          the method `PublishGroup' of an already created instance. The
          arguments 		FIELDSIZE and EXPONENTSIZE are stored
          for later following usage, 		e.g. by the method
          `CheckGroup' as explained below.  		If these
          arguments are omitted, then they are set to the default values
          `TMCG_DDH_SIZE' and `TMCG_DLSE_SIZE', respectively.



      -- Method on BarnettSmartVTMF_dlog_GroupQR: bool CheckGroup ()
          		This method checks whether p and q have
          appropriate sizes 		with respect to the bit lengths
          given during the initialization of the
          corresponding instance. Further, it checks whether p has the
          correct 		form (i.e. p = 2q +1), whether p and q
          are probable 		prime, and whether g is a generator of
          the subgroup G. It 		returns `true', if all of these
          checks have been passed successfully.



      -- Method on BarnettSmartVTMF_dlog_GroupQR: void PublishGroup
               (`std::ostream&' out)
          		This method exports all necessary group
          parameters of G to 		the given output stream OUT, so
          other VTMF instances of G 		can be initialized,
          e.g. with the second constructor of
          `BarnettSmartVTMF_dlog_GroupQR'.



      -- Method on BarnettSmartVTMF_dlog_GroupQR: void
     KeyGenerationProtocol_GenerateKey ()
          		This method generates a VTMF key pair and
          stores the pair internally for 		a later
          following usage. It must be called before any other part
          of the key generation protocol is executed. Otherwise, the
          produced results 		are wrong.



      -- Method on BarnettSmartVTMF_dlog_GroupQR: void
     KeyGenerationProtocol_PublishKey (`std::ostream&' out)
          		This method exports the public part of the
          generated VTMF key pair to the 		given output
          stream OUT. Further, it appends a non-interactive
          zero-knowledge proof of knowledge which shows that the
          instance knows the 		secret part.  		Due to
          the non-interactive nature of this proof the method has to be
          called 		only once while the computed output can
          be reused multiple times if necessary.



      -- Method on BarnettSmartVTMF_dlog_GroupQR: bool
     KeyGenerationProtocol_UpdateKey (`std::istream&' in)
          		This method reads the public part of a VTMF key
          and the proof of knowledge 		from the input stream
          IN. It appends the key to the common public key
          and returns `true', if the given proof was sound. Otherwise,
          `false' 		is returned.



      -- Method on BarnettSmartVTMF_dlog_GroupQR: bool
     KeyGenerationProtocol_RemoveKey (`std::istream&' in)
          		This method reads the public part of a VTMF key
          and the corresponding proof 		of knowledge from the
          input stream IN. It removes the key from the 		common
          public key and returns `true', if the key was previously
          appended 		by `KeyGenerationProtocol_UpdateKey' as
          explained above.



      -- Method on BarnettSmartVTMF_dlog_GroupQR: void
     KeyGenerationProtocol_Finalize ()
          		This method must be called after any update
          (`KeyGenerationProtocol_UpdateKey') or removal
          (`KeyGenerationProtocol_RemoveKey') has been performed
          on the common public key.



      --  on BarnettSmartVTMF_dlog_GroupQR:
     ~BarnettSmartVTMF_dlog_GroupQR ()
          		This destructor releases all occupied resources.

2.2.2.2 Verifiable Secret Shuffle of Homomorphic Encryptions
............................................................

Recently, Groth [Gr05] has proposed a very efficient solution to perform
a verifiable shuffle of homomorphically encrypted values. He describes
an honest verifier zero-knowledge argument which shows the correctness
of a shuffle. Beside other applications (e.g. verifiable mix networks,
electronic voting) his protocol can be used to show (with overwhelming
probability) that the secret shuffle of a deck of cards was performed
correctly. The computational complexity and the produced communication
traffic are superior to previously deployed techniques (e.g.
Schindelhauer's cut-and-choose method).  LibTMCG provides the first
known implementation of Groth's famous protocol.  However, it can only
be used along with the VTMF card encoding scheme of Barnett and
Smart [BS03].

   Our implementation uses the statistically hiding and computationally
binding homomorphic commitment scheme due to Pedersen (see
_Non-interactive and Information-theoretic Secure Verifiable Secret
Sharing_, CRYPTO '91, LNCS 576). The binding property relies on the
hardness of computing discrete logarithms in G, and thus a commitment
is only binding for computationally bounded provers.(1) But this choice
seems to be reasonable for the intention of LibTMCG, because all
players are supposed to be computationally bounded. The security
parameters of the commitment scheme (in particular the group G) are
determined by the corresponding VTMF instance.

   Further, to the best of our knowledge it is not known, whether
Groth's protocol retains the zero-knowledge property when it is
executed in a concurrent setting.  Thus the application programmer
should be careful and avoid parallel invocations of the same instance.

 -- Class: GrothVSSHE
     	This class provides the low-level interface for Groth's
     protocol.  	There are just a few methods that might be of
     general interest.  	All other components are only used
     internally by high-level operations 	and thus their
     description is omitted here.



      -- Constructor on GrothVSSHE:  GrothVSSHE (`size_t' n,
               `mpz_srcptr' p_ENC, `mpz_srcptr' q_ENC, `mpz_srcptr'
               k_ENC, `mpz_srcptr' g_ENC, `mpz_srcptr' h_ENC, `unsigned
               long int' ell_e `=TMCG_GROTH_L_E', `unsigned long int'
               fieldsize `=TMCG_DDH_SIZE', `unsigned long int'
               subgroupsize `=TMCG_DLSE_SIZE')
          		This constructor creates a new instance. The
          low-level operations 		are later used to show the
          correctness of a shuffle of at most 		N cards. The
          protocol and some parameters of the commitment
          scheme are initialized by the members of the corresponding
          VTMF 		instance. Consequently, P_ENC is the prime
          number p 		which determines the field \bf Z/p\bf
          Z, Q_ENC 		is the order of the underlying subgroup
          G, i.e. the prime 		number q, and K_ENC is the
          integer such that 		p = qk + 1 holds. Further,
          G_ENC is the generator 		g, and finally H_ENC is
          the common public key h.  		The positive integer
          ELL_E is the security parameter which
          controls the soundness error probability (2^-\ell_e) of
          the protocol. The default value is defined by
          `TMCG_GROTH_L_E', if this argument is omitted. The FIELDSIZE
          and the SUBGROUPSIZE are supplied to internal classes
          and are only of interest, if P_ENC or Q_ENC have
          lengths different from the default. If these arguments are
          omitted, they are set to `TMCG_DDH_SIZE' and `TMCG_DLSE_SIZE',
          respectively.

          		Note that the generators g'_1, \ldots, g'_n of
          the Pedersen 		commitment scheme are randomly and
          uniformly chosen from \bf Z_q.  		Therefore this
          constructor should be instantiated only once by the session
          leader. All other instances must be created by the second
          constructor.  		Further, it is very important
          that the VTMF key generation protocol 		has
          been finished before the value of h is passed to the
          constructor. Otherwise, the correctness verification will
          definitely fail.



      -- Constructor on GrothVSSHE:  GrothVSSHE (`size_t' n,
               `std::istream&' in, `unsigned long int' ell_e
               `=TMCG_GROTH_L_E', `unsigned long int' fieldsize
               `=TMCG_DDH_SIZE', `unsigned long int' subgroupsize
               `=TMCG_DLSE_SIZE')
          		This constructor initializes the instance from
          a correctly formatted 		input stream IN. For
          example, such a stream can be generated by 		calling
          the method `PublishGroup' of an already created instance.
          Later the instance can be used to show the correctness of a
          shuffle of 		at most N cards.  		The
          positive integer ELL_E controls the soundness error
          probability 		of the protocol. The default value is
          defined by `TMCG_GROTH_L_E', 		if this argument is
          omitted.



      -- Method on GrothVSSHE: bool CheckGroup ()
          		This method checks whether the initialized
          commitment scheme is sound.  		It returns `true', if
          all tests have been passed successfully.



      -- Method on GrothVSSHE: void PublishGroup (`std::ostream&' out)
          		This method exports the instance configuration
          to the output stream 		OUT such that other instances
          can be initialized, e.g. with the 		second
          constructor.



      -- Destructor on GrothVSSHE: ~GrothVSSHE ()
          		This destructor releases all occupied resources.

2.2.2.3 Toolbox for Mental Card Games
.....................................

This section explains the main class of LibTMCG which provides all
"high-level operations" from Schindelhauer's toolbox [Sc98].  Even if
the more efficient card encoding scheme of Barnett and Smart [BS03] is
deployed, at least one instance of the following class must be created
to perform any card or stack operations.

 -- Class: SchindelhauerTMCG
     	This class implements the main core of Schindelhauer's toolbox,
     i.e. important functions like masking, opening, and shuffling of
     cards and stacks, respectively. Some exotic operations are still
     missing, 	e.g., the possibility to insert a masked card secretly
     into a stack or 	the verifiable subset properties of stacks.
     All implemented operations are available for the original encoding
     scheme 	of Schindelhauer (see `TMCG_Card') and, of course, for
     the more efficient 	encoding scheme of Barnett and Smart
     (see `VTMF_Card' and 	`BarnettSmartVTMF_dlog') as well.



      -- Member of SchindelhauerTMCG: unsigned long int
     TMCG_SecurityLevel
          		This read-only nonnegative integer represents
          the security parameter t 		which was given to the
          constructor of this class. It defines the number of
          protocol iterations and hence the soundness error probability
          (2^-t) 		of the zero-knowledge proofs in the
          encoding scheme of Schindelhauer.  		Further it
          defines the soundness error probability (also 2^-t)
          of the shuffle argument in the encoding scheme of Barnett and
          Smart, if 		the efficient protocol of Groth [Gr05]
          is not used.



      -- Member of SchindelhauerTMCG: size_t TMCG_Players
          		This read-only nonnegative integer represents
          the number of players as 		given to the
          constructor of this class.



      -- Member of SchindelhauerTMCG: size_t TMCG_TypeBits
          		This read-only nonnegative integer contains the
          number of bits that are 		necessary to encode the
          card types in the binary representation. It was
          given as an argument to the constructor of this class.



      -- Constructor on SchindelhauerTMCG:  SchindelhauerTMCG
               (`unsigned long int' security, `size_t' k, `size_t' w)
          		This constructor creates an instance, where
          SECURITY is a nonnegative 		integer that represents
          the security parameter t. The parameter K 		is the
          number of players and W is the number of bits which are
          necessary 		to represent all possible card types in
          a binary representation.

          		The integer t controls the maximum soundness
          error probability (2^-t) 		of the zero-knowledge
          proofs in the encoding scheme of Schindelhauer.
          Specifically, SECURITY defines the number of sequential
          iterations of 		the involved protocols and thus
          has a major impact on the computational 		and
          communication complexity. If the encoding scheme of Barnett
          and 		Smart [BS03] is used, then it only defines the
          soundness error 		probability (also 2^-t) of the
          shuffle proof. However, if only 		the efficient
          shuffle verification protocol of Groth [Gr05] is used,
          then the parameter SECURITY is dispensable, because the
          parameter ELL_E 		given during instantiation of
          `GrothVSSHE' (e.g. the LibTMCG default security
          parameter `TMCG_GROTH_L_E') determines this soundness error
          probability 		(2^-\ell_e).

          		Unfortunately, the parameters K and W have a
          major impact on the 		complexity in the encoding
          scheme of Schindelhauer, too. Therefore you should always use
          reasonable values. For example, to create a deck with M
          different card types 		simply set W to \lceil\log_2
          M\rceil which is an tight upper-bound for 		the
          binary representation. Furthermore, set K to the
          number of players which are really involved and not to a
          possible maximum value.  		Note that K and W are
          limited by the global constants
          `TMCG_MAX_PLAYERS' and `TMCG_MAX_TYPEBITS', respectively.



      -- Method on SchindelhauerTMCG: void TMCG_CreateOpenCard
               (`TMCG_Card&' c, `const TMCG_PublicKeyRing&' ring,
               `size_t' type)
          		This method initializes the open card C with
          the given TYPE 		using the encoding scheme of
          Schindelhauer. The TYPE MUST be an 		integer from
          the interval [0, 2^w - 1], where w is the 		number
          given to the constructor of this class. The w MUST be the
          same number as used at creation of C (see `TMCG_Card'). The
          parameter RING is a container with exactly k public keys,
          where k is the number given to the constructor of this class.
          The k MUST be the same number as used at the creation of C.



      -- Method on SchindelhauerTMCG: void TMCG_CreateOpenCard
               (`VTMF_Card&' c, `BarnettSmartVTMF_dlog*' vtmf, `size_t'
               type)
          		This method initializes the open card C with
          the given TYPE 		using the encoding scheme of
          Barnett and Smart. The TYPE MUST be an 		integer
          from the interval [0, 2^w - 1], where w is the
          number given to the constructor of this class. The parameter
          VTMF 		is a pointer to an already initialized VTMF
          instance, i.e. the key 		generation protocol was
          successfully finished (see `BarnettSmartVTMF_dlog'
          and `BarnettSmartVTMF_dlog_GroupQR', respectively).



      -- Method on SchindelhauerTMCG: void TMCG_CreateCardSecret
               (`TMCG_CardSecret&' cs, `const TMCG_PublicKeyRing&'
               ring, `size_t' index)
          		This method initializes the card secret CS with
          random values 		which is necessary to perform
          later a masking operation on a card.  		The
          parameter RING is a container with exactly k public
          keys, where k is the number given to the constructor of this
          class. It MUST be the same number as used at the creation of
          CS 		(see `TMCG_CardSecret'). The parameter INDEX is
          from the 		interval [0, k - 1] and determines the
          position of the players 		public key in the
          container RING.



      -- Method on SchindelhauerTMCG: void TMCG_CreateCardSecret
               (`VTMF_CardSecret&' cs, `BarnettSmartVTMF_dlog*' vtmf)
          		This method initializes the card secret CS with
          a random value 		which is necessary to perform
          later a masking operation on a card.  		The
          parameter VTMF is a pointer to an already initialized VTMF
          instance, i.e. the key generation protocol MUST be
          successfully finished 		(see
          `BarnettSmartVTMF_dlog' and `BarnettSmartVTMF_dlog_GroupQR',
          respectively).



      -- Method on SchindelhauerTMCG: void TMCG_CreatePrivateCard
               (`TMCG_Card&' c, `TMCG_CardSecret&' cs, `const
               TMCG_PublicKeyRing&' ring, `size_t' index, `size_t' type)
          		This method initializes a masked card C with
          the given TYPE and 		a corresponding card secret CS
          using the encoding scheme of 		Schindelhauer.
          The TYPE MUST be an integer from the interval [0, 2^w - 1],
          where w is the number given to the constructor of this class.
          The 		w MUST be the same number as used at creation
          of C (see 		`TMCG_Card') and CS (see
          `TMCG_CardSecret'). The parameter 		RING is a
          container with exactly k public keys, where k
          is the number given to the constructor of this class. The k
          MUST be 		the same number as used at the creation
          of C and CS. The parameter 		INDEX is from the
          interval [0, k - 1] and determines the
          position of the players public key in the container RING.
          Internally, `TMCG_CreatePrivateCard' calls


            1. `TMCG_CreateOpenCard' to initialize C with TYPE,

            2. `TMCG_CreateCardSecret' to initialize CS with random
               values, and

            3. `TMCG_MaskCard' to mask C with the secret CS.




      -- Method on SchindelhauerTMCG: void TMCG_CreatePrivateCard
               (`VTMF_Card&' c, `VTMF_CardSecret&' cs,
               `BarnettSmartVTMF_dlog*' vtmf, `size_t' type)
          		This method initializes a masked card C with
          the given TYPE and 		a corresponding card secret CS
          using the encoding scheme of Barnett and 		Smart.
          The TYPE MUST be an integer from the interval
          [0, 2^w - 1], where w is the number given to the constructor
          of this class. The parameter VTMF is a pointer to an already
          initialized 		VTMF instance, i.e. the key generation
          protocol MUST be successfully finished 		(see
          `BarnettSmartVTMF_dlog' and `BarnettSmartVTMF_dlog_GroupQR',
          respectively). Specifically, `TMCG_CreatePrivateCard'
          directly executes 		the masking operation of the
          verifiable masking protocol.



      -- Method on SchindelhauerTMCG: void TMCG_MaskCard (`const
               TMCG_Card&' c, `TMCG_Card&' cc, `const TMCG_CardSecret&'
               cs, `const TMCG_PublicKeyRing&' ring, `bool'
               TimingAttackProtection `=true')
          		This method performs a masking operation on the
          open or already masked card 		C using the encoding
          scheme of Schindelhauer. Finally it returns the
          result in CC.  		The parameter CS MUST be an
          initialized fresh card secret which has NEVER
          been involved in a masking operation before. The parameters
          C, CC, 		and CS MUST be created such that their
          k and w 		corresponds to the numbers given to the
          constructor of this class, 		respectively. The
          parameter RING is a container with exactly 		k
          public keys.  		The protection against timing
          attacks is turned on, if 		TIMINGATTACKPROTECTION
          is set to `true'.



      -- Method on SchindelhauerTMCG: void TMCG_MaskCard (`const
               VTMF_Card&' c, `VTMF_Card&' cc, `const VTMF_CardSecret&'
               cs, `BarnettSmartVTMF_dlog*' vtmf, `bool'
               TimingAttackProtection `=true')
          		This method performs a masking operation on the
          open or already masked card 		C using the encoding
          scheme of Barnett and Smart. Finally it returns the
          result in CC. Specifically, `TMCG_MaskCard' directly executes
          the masking operation of the verifiable re-masking protocol.
          The parameter CS MUST be an initialized fresh card secret
          which has 		NEVER been involved in a masking
          operation before.  		The parameter VTMF is a pointer
          to an already initialized 		VTMF instance, i.e. the
          key generation protocol MUST be successfully finished
          (see `BarnettSmartVTMF_dlog' and
          `BarnettSmartVTMF_dlog_GroupQR', 		respectively).
          The protection against timing attacks is turned on, if
          TIMINGATTACKPROTECTION is set to `true'.



      -- Method on SchindelhauerTMCG: void TMCG_ProveMaskCard (`const
               TMCG_Card&' c, `const TMCG_Card&' cc, `const
               TMCG_CardSecret&' cs, `const TMCG_PublicKeyRing&' ring,
               `std::istream&' in, `std::ostream&' out)
          		This method should be called by the prover
          after `TMCG_MaskCard' to show 		that he
          performed the masking operation correctly. The parameters C,
          CC, and CS are the input, the result, and the used card secret
          of `TMCG_MaskCard', respectively.  		They MUST be
          created such that their k resp. w 		corresponds to
          the numbers given to the constructor of this class. The
          parameter RING is a container with exactly k public keys.
          The input/output protocol messages from and to the verifier
          are 		transmitted on the streams IN and OUT,
          respectively.



      -- Method on SchindelhauerTMCG: void TMCG_ProveMaskCard (`const
               VTMF_Card&' c, `const VTMF_Card&' cc, `const
               VTMF_CardSecret&' cs, `BarnettSmartVTMF_dlog*' vtmf,
               `std::istream&' in, `std::ostream&' out)
          		This method should be executed by the prover
          after calling `TMCG_MaskCard' 		to show that he
          performed the masking operation correctly. Specifically,
          `TMCG_ProveMaskCard' directly calls the prove operation of the
          verifiable re-masking protocol.  		The parameters
          C, CC, and CS are the input, the result, and 		the
          used card secret of `TMCG_MaskCard', respectively.
          The parameter VTMF is a pointer to an already initialized
          VTMF instance, 		i.e. the key generation
          protocol MUST be successfully finished.  		The
          input/output protocol messages from and to the verifier are
          transmitted on the streams IN and OUT, respectively.



      -- Method on SchindelhauerTMCG: bool TMCG_VerifyMaskCard (`const
               TMCG_Card&' c, `const TMCG_Card&' cc, `const
               TMCG_PublicKeyRing&' ring, `std::istream&' in,
               `std::ostream&' out)
          		This method should be executed by the verifier
          to check whether or not a 		masking operation was
          performed correctly. The parameters C and 		CC are
          the input and the result of `TMCG_MaskCard', respectively.
          They MUST be created such that their k resp. w corresponds to
          the numbers given to the constructor of this class.
          The parameter RING is a container with exactly k public keys.
          The input/output protocol messages from and to the prover are
          transmitted on the streams IN and OUT, respectively.
          The method returns `true', if everything was sound.



      -- Method on SchindelhauerTMCG: bool TMCG_VerifyMaskCard (`const
               VTMF_Card&' c, `const VTMF_Card&' cc,
               `BarnettSmartVTMF_dlog*' vtmf, `std::istream&' in,
               `std::ostream&' out)
          		This method should be executed by the verifier
          to check whether or not a 		masking operation was
          performed correctly. Specifically,
          `TMCG_VerifyMaskCard' directly calls the verify operation of
          the 		verifiable re-masking protocol. The parameters
          C and 		CC are the input and the result of
          `TMCG_MaskCard', respectively.  		The parameter
          VTMF is a pointer to an already initialized VTMF instance,
          i.e. the key generation protocol MUST be successfully
          finished.  		The input/output protocol messages from
          and to the prover are 		transmitted on the
          streams IN and OUT, respectively.  		The method
          returns `true', if everything was sound.



      -- Method on SchindelhauerTMCG: void TMCG_ProveCardSecret (`const
               TMCG_Card&' c, `const TMCG_SecretKey&' key, `size_t'
               index, `std::istream&' in, `std::ostream&' out)
          		This method is used to reveal the card type of
          C to a verifier.  		Every player must execute this
          method as prover.  		The card C MUST be created such
          that its k resp. w 		corresponds to the numbers
          given to the constructor of this class.  		The
          parameter KEY is the corresponding secret key (see
          `TMCG_SecretKey') of the prover. The parameter INDEX is from
          the 		interval [0, k - 1] and contains the position
          of the provers 		public key in the container
          RING (same as in `TMCG_CreateCardSecret').  		The
          input/output protocol messages from and to the verifier are
          transmitted on the streams IN and OUT, respectively.



      -- Method on SchindelhauerTMCG: void TMCG_ProveCardSecret (`const
               VTMF_Card&' c, `BarnettSmartVTMF_dlog*' vtmf,
               `std::istream&' in, `std::ostream&' out)
          		This method is used to reveal the card type of
          C to a verifier.  		Every player must execute this
          method as prover.  		Specifically,
          `TMCG_ProveCardSecret' directly calls the prove operation of
          the 		verifiable decryption protocol.
          The parameter VTMF is a pointer to an already initialized
          VTMF instance, 		i.e. the key generation
          protocol MUST be successfully finished.  		The
          input/output protocol messages from and to the verifier are
          transmitted on the streams IN and OUT, respectively.



      -- Method on SchindelhauerTMCG: bool TMCG_VerifyCardSecret
               (`const TMCG_Card&' c, `TMCG_CardSecret&' cs, `const
               TMCG_PublicKey&' key, `size_t' index, `std::istream&'
               in, `std::ostream&' out)
          		This method is used to verify and accumulate
          card type information regarding 		C that are
          supplied by a prover. It is the opposite method of
          `TMCG_ProveCardSecret' and must be executed by the player who
          wants to 		know the type. The secrets provided by
          the single provers are accumulated in 		the
          parameter CS.  		Thus C and CS MUST be created
          such that their k resp. w 		corresponds to the
          numbers given to the constructor of this class.
          The parameter KEY is the corresponding public key (see
          `TMCG_PublicKey') 		of the prover. The parameter
          INDEX is from the interval [0, k - 1] 		and
          contains the position of the provers public key in the
          container RING 		(same as in
          `TMCG_CreateCardSecret').  		The input/output
          protocol messages from and to the prover are
          transmitted on the streams IN and OUT, respectively.



      -- Method on SchindelhauerTMCG: bool TMCG_VerifyCardSecret
               (`const VTMF_Card&' c, `BarnettSmartVTMF_dlog*' vtmf,
               `std::istream&' in, `std::ostream&' out)
          		This method is used to verify and accumulate
          card type information regarding 		C that are
          supplied by a prover. It is the opposite method of
          `TMCG_ProveCardSecret' and must be executed by the player who
          wants 		to know the type. The secrets provided
          by the single provers are accumulated
          internally, thus this method cannot be interleaved with the
          opening of other 		cards.
          Specifically, `TMCG_VerifyCardSecret' directly calls the
          verify 		and update operation of the verifiable
          decryption protocol.  		The parameter VTMF is a
          pointer to an already initialized VTMF instance,
          i.e. the key generation protocol MUST be successfully
          finished.  		The input/output protocol messages from
          and to the verifier are 		transmitted on the
          streams IN and OUT, respectively.



      -- Method on SchindelhauerTMCG: void TMCG_SelfCardSecret (`const
               TMCG_Card&' c, `TMCG_CardSecret&' cs, `const
               TMCG_SecretKey&' key, `size_t' index)
          		This method is used to compute and accumulate
          card type information regarding 		C. Analogously
          to `TMCG_VerifyCardSecret' it must be executed by the
          player who wants to know the type of C. The information is
          accumulated in 		the parameter CS.
          Thus C and CS MUST be created such that their k resp. w
          corresponds to the numbers given to the constructor of this
          class.  		The parameter KEY is the corresponding
          secret key (see `TMCG_SecretKey') 		of the player.
          The parameter INDEX is from the interval [0, k - 1]
          and contains the position of the players public key in the
          container RING 		(same as in
          `TMCG_CreateCardSecret').



      -- Method on SchindelhauerTMCG: void TMCG_SelfCardSecret (`const
               VTMF_Card&' c, `BarnettSmartVTMF_dlog*' vtmf)
          		This method is used to compute and accumulate
          card type information regarding 		C. It MUST be
          called by the player who wants to know the type of C
          BEFORE `TMCG_VerifyCardSecret' and `TMCG_TypeOfCard' are
          executed.  		The secrets provided by the player are
          accumulated internally, thus this method 		cannot
          be interleaved with the opening of other cards.
          Specifically, `TMCG_SelfCardSecret' directly calls the
          initialize operation 		of the verifiable decryption
          protocol.  		The parameter VTMF is a pointer to an
          already initialized VTMF instance, 		i.e. the key
          generation protocol MUST be successfully finished.



      -- Method on SchindelhauerTMCG: size_t TMCG_TypeOfCard (`const
               TMCG_CardSecret&' cs)
          		This method returns the type of a masked card
          provided that the type 		information were
          properly accumulated in CS before (by calling
          `TMCG_SelfCardSecret' and `TMCG_VerifyCardSecret',
          respectively).



      -- Method on SchindelhauerTMCG: size_t TMCG_TypeOfCard (`const
               VTMF_Card&' c, `BarnettSmartVTMF_dlog*' vtmf)
          		This method returns the type of a masked card C
          provided that the type 		information regarding C
          were properly accumulated internally before (by calling
          `TMCG_SelfCardSecret' and `TMCG_VerifyCardSecret',
          respectively).  		It returns the value
          `TMCG_MaxCardType', if the opening operation 		failed
          or if the card type was not among the set of valid types.
          This method MUST be performed by the player who wants to know
          the type AFTER 		`TMCG_SelfCardSecret' and
          `TMCG_VerifyCardSecret' are executed.
          Specifically, `TMCG_TypeOfCard' directly calls the finalize
          operation 		of the verifiable decryption protocol.
          The parameter VTMF is a pointer to an already initialized
          VTMF instance, 		i.e. the key generation
          protocol MUST be successfully finished.



      -- Method on SchindelhauerTMCG: size_t TMCG_CreateStackSecret
               (`TMCG_StackSecret<TMCG_CardSecret>&' ss, `bool' cyclic,
               `const TMCG_PublicKeyRing&' ring, `size_t' index,
               `size_t' size)
          		This method initializes the stack secret SS
          with a randomly and 		uniformly chosen permutation
          (using the algorithm of Knuth) and fresh card secrets. Later
          this stack 		secret can be used to perform a secret
          shuffle operation on a stack.  		If the
          parameter CYCLIC is set to `true', then the permutation
          is only a cyclic shift which might be of interest for
          particular 		operations, e.g. cutting the deck.
          The parameter RING is a container with exactly k public
          keys, where k is the number given to the constructor of this
          class. The parameter INDEX is from the interval [0, k - 1]
          and contains the position of the players public key in the
          container 		RING. The parameter SIZE determines the
          size of the created 		stack secret, i.e. the number
          of cards in the corresponding stack. The 		SIZE is
          upper-bounded by `TMCG_MAX_CARDS'.  		The method
          returns the offset of the cyclic shift, if CYCLIC was set
          to `true'. Otherwise, the value `0' is returned.



      -- Method on SchindelhauerTMCG: size_t TMCG_CreateStackSecret
               (`TMCG_StackSecret<VTMF_CardSecret>&' ss, `bool' cyclic,
               `size_t' size, `BarnettSmartVTMF_dlog*' vtmf)
          		This method initializes the stack secret SS
          with a randomly and 		uniformly chosen permutation
          (using the algorithm of Knuth) and fresh card secrets. Later
          this stack 		secret can be used to perform a secret
          shuffle operation on a stack.  		If the
          parameter CYCLIC is set to `true', then the permutation
          is only a cyclic shift which might be of interest for
          particular 		operations, e.g. cutting the deck.
          The parameter SIZE determines the size of the created
          stack secret, i.e. the number of cards in the corresponding
          stack. The 		SIZE is upper-bounded by
          `TMCG_MAX_CARDS'.  		The parameter VTMF is a pointer
          to an already initialized VTMF instance, 		i.e.
          the key generation protocol MUST be successfully finished.
          The method returns the offset of the cyclic shift, if CYCLIC
          was set 		to `true'. Otherwise, the value `0' is
          returned.



      -- Method on SchindelhauerTMCG: void TMCG_MixStack (`const
               TMCG_Stack<TMCG_Card>&' s, `TMCG_Stack<TMCG_Card>&' s2,
               `const TMCG_StackSecret<TMCG_CardSecret>&' ss, `const
               TMCG_PublicKeyRing&' ring, `bool' TimingAttackProtection
               `=true')
          		This method shuffles a given stack S according
          to the previously 		created stack secret SS (see
          `TMCG_CreateStackSecret'). The 		result of the
          shuffle is returned in S2.  		The parameter SS MUST
          be a fresh stack secret which has NEVER 		been
          involved in a shuffle operation before. The parameters S
          and SS MUST be of the same size. The parameter RING is a
          container with exactly k public keys, where k is the
          number given to the constructor of this class.
          The protection against timing attacks is turned on, if
          TIMINGATTACKPROTECTION is set to `true'.



      -- Method on SchindelhauerTMCG: void TMCG_MixStack (`const
               TMCG_Stack<VTMF_Card>&' s, `TMCG_Stack<VTMF_Card>&' s2,
               `const TMCG_StackSecret<VTMF_CardSecret>&' ss,
               `BarnettSmartVTMF_dlog*' vtmf, `bool'
               TimingAttackProtection `=true')
          		This method shuffles a given stack S according
          to the previously 		created stack secret SS (see
          `TMCG_CreateStackSecret'). The 		result of the
          shuffle is returned in S2.  		The parameter SS MUST
          be a fresh stack secret which has NEVER 		been
          involved in a shuffle operation before. The parameters S
          and SS MUST be of the same size.  		The parameter
          VTMF is a pointer to an already initialized VTMF instance,
          i.e. the key generation protocol MUST be successfully
          finished.  		The protection against timing attacks
          is turned on, if 		TIMINGATTACKPROTECTION is set
          to `true'.



      -- Method on SchindelhauerTMCG: void TMCG_ProveStackEquality
               (`const TMCG_Stack<TMCG_Card>&' s, `const
               TMCG_Stack<TMCG_Card>&' s2, `const
               TMCG_StackSecret<TMCG_CardSecret>&' ss, `bool' cyclic,
               `const TMCG_PublicKeyRing&' ring, `size_t' index,
               `std::istream&' in, `std::ostream&' out)
          		This method should be called by the prover
          after `TMCG_MixStack' to show 		that he
          performed the shuffle operation correctly. The parameters S,
          S2, and SS are the input, the result, and the used stack
          secret 		of `TMCG_MixStack', respectively.
          Of course, the parameters S, S2, and SS MUST be of the same
          size.  		The parameter CYCLIC determines whether
          a cyclic shift or a full permutation 		was used to
          shuffle the stack.  		The parameter RING is a
          container with exactly k public keys, where 		k is
          the number given to the constructor of this class.
          The parameter INDEX is from the interval [0, k - 1] and
          contains the 		position of the provers public key in
          the container RING.  		The input/output protocol
          messages from and to the verifier are
          transmitted on the streams IN and OUT, respectively.



      -- Method on SchindelhauerTMCG: void TMCG_ProveStackEquality
               (`const TMCG_Stack<VTMF_Card>&' s, `const
               TMCG_Stack<VTMF_Card>&' s2, `const
               TMCG_StackSecret<VTMF_CardSecret>&' ss, `bool' cyclic,
               `BarnettSmartVTMF_dlog*' vtmf, `std::istream&' in,
               `std::ostream&' out)
          		This method should be called by the prover
          after `TMCG_MixStack' to show 		that he
          performed the shuffle operation correctly. The parameters S,
          S2, and SS are the input, the result, and the used stack
          secret 		of `TMCG_MixStack', respectively.
          Of course, the parameters S, S2, and SS MUST be of the same
          size.  		The parameter CYCLIC determines whether
          a cyclic shift or a full permutation 		was used to
          shuffle the stack.  		The parameter VTMF is a pointer
          to an already initialized VTMF instance, 		i.e.
          the key generation protocol MUST be successfully finished.
          The input/output protocol messages from and to the verifier
          are 		transmitted on the streams IN and OUT,
          respectively.



      -- Method on SchindelhauerTMCG: void
               TMCG_ProveStackEquality_Groth (`const
               TMCG_Stack<VTMF_Card>&' s, `const
               TMCG_Stack<VTMF_Card>&' s2, `const
               TMCG_StackSecret<VTMF_CardSecret>&' ss,
               `BarnettSmartVTMF_dlog*' vtmf, `GrothVSSHE*' vsshe,
               `std::istream&' in, `std::ostream&' out)
          		This is a method like above. The only
          difference is that the more 		efficient shuffle
          verification protocol of Groth is used. Thus VSSHE
          is a pointer to an initialized instance of `GrothVSSHE'.
          The rest of the arguments are the same.



      -- Method on SchindelhauerTMCG: bool TMCG_VerifyStackEquality
               (`const TMCG_Stack<TMCG_Card>&' s, `const
               TMCG_Stack<TMCG_Card>&' s2, `bool' cyclic, `const
               TMCG_PublicKeyRing&' ring, `std::istream&' in,
               `std::ostream&' out)
          		This method should be executed by the verifier
          to check whether or not a 		shuffle operation was
          performed correctly. The parameters S and 		S2 are
          the input and the result of `TMCG_MixStack', respectively.
          Of course, the parameters S and S2 should be of the same size.
          The parameter CYCLIC determines whether a cyclic shift or a
          full permutation 		was used to shuffle the stack.
          The parameter RING is a container with exactly k public keys,
          where 		k is the number given to the
          constructor of this class.  		The input/output
          protocol messages from and to the prover are
          transmitted on the streams IN and OUT, respectively.
          This method returns `true', if the shuffle operation was
          successfully verified.



      -- Method on SchindelhauerTMCG: bool TMCG_VerifyStackEquality
               (`const TMCG_Stack<VTMF_Card>&' s, `const
               TMCG_Stack<VTMF_Card>&' s2, `bool' cyclic,
               `BarnettSmartVTMF_dlog*' vtmf, `std::istream&' in,
               `std::ostream&' out)
          		This method should be executed by the verifier
          to check whether or not a 		shuffle operation was
          performed correctly. The parameters S and 		S2 are
          the input and the result of `TMCG_MixStack', respectively.
          Of course, the parameters S and S2 should be of the same size.
          The parameter CYCLIC determines whether a cyclic shift or a
          full permutation 		was used to shuffle the stack.
          The parameter VTMF is a pointer to an already initialized
          VTMF instance, 		i.e. the key generation
          protocol MUST be successfully finished.  		The
          input/output protocol messages from and to the verifier are
          transmitted on the streams IN and OUT, respectively.
          This method returns `true', if the shuffle operation was
          successfully verified.



      -- Method on SchindelhauerTMCG: bool
     TMCG_VerifyStackEquality_Groth (`const TMCG_Stack<VTMF_Card>&' s,
               `const TMCG_Stack<VTMF_Card>&' s2,
               `BarnettSmartVTMF_dlog*' vtmf, `GrothVSSHE*' vsshe,
               `std::istream&' in, `std::ostream&' out)
          		This is a method like above. The only
          difference is that the more 		efficient shuffle
          verification protocol of Groth is used. Thus VSSHE
          is a pointer to an initialized instance of `GrothVSSHE'.
          The rest of the arguments and the returned values are the
          same.



      -- Destructor on SchindelhauerTMCG: ~SchindelhauerTMCG ()
          		This destructor releases all occupied resources.

   ---------- Footnotes ----------

   (1) Strictly speaking, due to this reason Groth's protocol is a
zero-knowledge _argument_ instead of a zero-knowledge _proof_. However,
for convenience we will not distinguish between these terms here.


File: libTMCG.info,  Node: Examples,  Next: Licenses,  Prev: Application Programming Interface,  Up: Top

3 Examples
**********

The following examples explain most of the steps that are necessary to
create a secure and fair card game with LibTMCG. We consider an
application with five permanent players (denoted by P_0, P_1, P_2, P_3,
and P_4) and a regular deck of 52 different cards. For convenience only
the more efficient card encoding scheme of Barnett and Smart [BS03] is
described. Additionally, we complete our exposition with code fragments
which show the usage of the fast shuffle verification protocol due to
Groth [Gr05].

   Throughout the remaining pages we suppose that all players are
pairwise connected by authenticated communication channels. These
channels are organized in input resp.  output streams, where
`input_stream[i]' resp. `output_stream[i]' denote the corresponding
`std::istream' resp. `std::ostream' instance for the communication with
player P_i.(1)

* Menu:

* Library Initialization::
* Session Initialization and Key Generation::
* Operations on Cards::
* Operations on Stacks::
* Quit a Session::

   ---------- Footnotes ----------

   (1) We assume that the players are ordered in a natural way such
that we can use the same nomenclature.


File: libTMCG.info,  Node: Library Initialization,  Next: Session Initialization and Key Generation,  Up: Examples

3.1 Library Initialization
==========================

The very first step that should be performed is the initialization of
LibTMCG.  That can simply be done by calling the function
`init_libTMCG' and evaluating the return code.
     if (!init_libTMCG())
       std::cerr << "Initialization of LibTMCG failed!" << std::endl;
Additionally, in the most cases it is useful to check the installed
library version by using the function `version_libTMCG'.


File: libTMCG.info,  Node: Session Initialization and Key Generation,  Next: Operations on Cards,  Prev: Library Initialization,  Up: Examples

3.2 Session Initialization and Key Generation
=============================================

In the next step we create an instance of the class `SchindelhauerTMCG'.
The first parameter determines the number of protocol iterations t
which upper-bounds the cheating probability by 2^-t. In our example the
used value `64' defines a maximum cheating probability of
5.421010862\cdot 10^-20 which is reasonable small for our purposes. The
second parameter passes the number of players to the instance which is
simply `5' in our case. The last argument defines the number of bits
that are necessary to encode all card types in a binary representation.
The given value `6' allows the encoding of 2^6 = 64 different card
types at maximum. This is enough to form our deck of 52 cards.
     SchindelhauerTMCG *tmcg = new SchindelhauerTMCG(64, 5, 6);
We would like to use the more efficient encoding scheme of Barnett and
Smart, thus we create an instance of `BarnettSmartVTMF_dlog'. However,
a particular player has to act as a _leader_ who performs the
generation of the group G. In our case P_0 will be the session leader.
First, he executes the constructor of `BarnettSmartVTMF_dlog'.
     BarnettSmartVTMF_dlog *vtmf = new BarnettSmartVTMF_dlog();
Afterwards he checks the generated group G and sends the public
parameters to all other players (corresponding stream indices are `1',
`2', `3', and `4', respectively).
     if (!vtmf->CheckGroup())
       std::cerr << "Group G was not correctly generated!" << std::endl;
     for (size_t i = 1; i < 5; i++)
       vtmf->PublishGroup(output_stream[i]);
The other players receive the group parameters from P_0 and use them to
initialize their corresponding instances of `BarnettSmartVTMF_dlog'.
It is very important that they also check, whether the group G was
correctly generated by the leader.
     BarnettSmartVTMF_dlog *vtmf =
       new BarnettSmartVTMF_dlog(input_stream[0]);
     if (!vtmf->CheckGroup())
       std::cerr << "Group G was not correctly generated!" << std::endl;
Afterwards the key generation protocol is carried out. First, every
player generates his own VTMF key. The secret key material is stored
internally and will never be exposed.
     vtmf->KeyGenerationProtocol_GenerateKey();
Then every player P_j sends the public part of his VTMF key along with a
non-interactive zero-knowledge proof of knowledge to each other player.
The appended proof shows that he indeed knows the corresponding secret
key.  However, due to the non-interactive nature of this proof we have
to be careful, if same group G is used again.
     for (size_t i = 0; i < 5; i++)
     {
       if (i != j)
         vtmf->KeyGenerationProtocol_PublishKey(output_stream[i]);
     }
After sending P_j receives the public keys. Simultaneously he checks,
whether the keys are correctly generated, and updates the common public
key h.
     for (size_t i = 0; i < 5; i++)
     {
       if (i != j)
       {
         if (!vtmf->KeyGenerationProtocol_UpdateKey(input_stream[i]))
           std::cerr << "Public key was not correctly generated!" << std::endl;
       }
     }
Finally, every player must finalize the key generation protocol.
     vtmf->KeyGenerationProtocol_Finalize();
If we want to use the more efficient shuffle verification protocol of
Groth, then P_0 must also create an instance of `GrothVSSHE'.  The
first argument determines the maximum stack size of which the
correctness of a shuffle will be proven. The other parameters are
obtained from the former created VTMF instance `vtmf'. It is important
that the key generation protocol has been finalized before the common
public key h (i.e. `vtmf->h') is passed.
     GrothVSSHE *vsshe = new GrothVSSHE(52, vtmf->p, vtmf->q, vtmf->k,
       vtmf->g, vtmf->h);
Again, P_0 will send the public parameters of the VSSHE instance to all
other players.
     for (size_t i = 1; i < 5; i++)
       vsshe->PublishGroup(output_stream[i]);
The other players receive these parameters from the leader and use them
to initialize their corresponding instances of `GrothVSSHE'.  Again, it
is important to check, whether the parameters were correctly chosen by
the leader.
     GrothVSSHE *vsshe = new GrothVSSHE(52, input_stream[0]);
     if (!vsshe->CheckGroup())
       std::cerr << "VSSHE was not correctly generated!" << std::endl;
     if (mpz_cmp(vtmf->h, vsshe->com->h))
       std::cerr << "VSSHE: Common public key does not match!" << std::endl;
     if (mpz_cmp(vtmf->q, vsshe->com->q))
       std::cerr << "VSSHE: Subgroup order does not match!" << std::endl;
     if (mpz_cmp(vtmf->p, vsshe->p) || mpz_cmp(vtmf->q, vsshe->q) ||
       mpz_cmp(vtmf->g, vsshe->g) || mpz_cmp(vtmf->h, vsshe->h))
         std::cerr << "VSSHE: Encryption scheme does not match!" << std::endl;


File: libTMCG.info,  Node: Operations on Cards,  Next: Operations on Stacks,  Prev: Session Initialization and Key Generation,  Up: Examples

3.3 Operations on Cards
=======================

Now we are ready to perform several operations on cards.  We start with
some basic stuff which might be of interest in particular situations.
However, it is often more convenient to work directly with stacks, as
explained later.

* Menu:

* Creating an Open Card::
* Masking and Re-masking of a Card::
* Opening a Masked Card::


File: libTMCG.info,  Node: Creating an Open Card,  Next: Masking and Re-masking of a Card,  Up: Operations on Cards

3.3.1 Creating an Open Card
---------------------------

The creation of an open card is very simple. The following code creates
a card of type `7'.
     VTMF_Card c;
     tmcg->TMCG_CreateOpenCard(c, vtmf, 7);


File: libTMCG.info,  Node: Masking and Re-masking of a Card,  Next: Opening a Masked Card,  Prev: Creating an Open Card,  Up: Operations on Cards

3.3.2 Masking and Re-masking of a Card
--------------------------------------

Now the previously created card `c' will be masked to hide its type.
Then `cc' is sent to P_1.
     VTMF_Card cc;
     VTMF_CardSecret cs;
     tmcg->TMCG_CreateCardSecret(cs, vtmf);
     tmcg->TMCG_MaskCard(c, cc, cs, vtmf);
     out_stream[1] << cc << std::endl;
P_1 receives the card `cc', re-masks them, and sends the result `ccc'
back to the player P_0. Further he proves that the masking operation
was performed correctly.
     VTMF_Card cc, ccc;
     VTMF_CardSecret ccs;
     in_stream[0] >> cc;
     if (!in_stream[0].good())
       std::cerr << "Read or parse error!" << std::endl;
     tmcg->TMCG_CreateCardSecret(ccs, vtmf);
     tmcg->TMCG_MaskCard(cc, ccc, ccs, vtmf);
     out_stream[0] << ccc << std::endl;
     tmcg->TMCG_ProveMaskCard(cc, ccc, ccs, vtmf, in_stream[0], out_stream[0]);
P_0 receives the card, verifies the proof, and sends the card to all
other players.
     VTMF_Card ccc;
     in_stream[1] >> ccc;
     if (!tmcg->TMCG_VerifyMaskCard(cc, ccc, vtmf, in_stream[1], out_stream[1]))
       std::cerr << "Verification failed!" << std::endl;
     for (size_t i = 1; i < 5; i++)
       out_stream[i] << ccc << std::endl;
Finally, all other players receive and store the masked card `ccc'.


File: libTMCG.info,  Node: Opening a Masked Card,  Prev: Masking and Re-masking of a Card,  Up: Operations on Cards

3.3.3 Opening a Masked Card
---------------------------

Suppose that P_1 would like to know the type of the masked card `ccc'.
Of course, P_0 could simply reveal it, but that isn't verifiable.
Anyway, if all players cooperate, then P_1 can compute the type in a
verifiable way. First, every player (except P_1) will execute the
following code.
     tmcg->TMCG_ProveCardSecret(ccc, vtmf, in_stream[1], out_stream[1]);
On the other hand, P_1 will execute the following commands exactly in
the given order. Finally, he obtain the card type in the variable
`type'.
     tmcg->TMCG_SelfCardSecret(ccc, vtmf);
     for (size_t i = 0; i < 5; i++)
     {
       if (i == 1)
         continue;
       if (!tmcg->TMCG_VerifyCardSecret(ccc, vtmf, in_stream[i], out_stream[i]))
         std::cerr << "Verification failed!" << std::endl;
     }
     type = tmcg->TMCG_TypeOfCard(ccc, vtmf);


File: libTMCG.info,  Node: Operations on Stacks,  Next: Quit a Session,  Prev: Operations on Cards,  Up: Examples

3.4 Operations on Stacks
========================

There exist a lot of basic operations on stacks, e.g. pushing a card to
a stack or importing a stack. These functions are to simple for
explaining them here, but they are used implicitly. However, a short
description can be found in the API part of the manual (see
`TMCG_Stack' and `TMCG_OpenStack').

* Menu:

* Creating the Deck::
* Shuffling the Deck::
* Drawing a Card from the Deck::


File: libTMCG.info,  Node: Creating the Deck,  Next: Shuffling the Deck,  Up: Operations on Stacks

3.4.1 Creating the Deck
-----------------------

A quite common operation is the creation of a card deck. The deck will
initially be represented by an open stack (see `TMCG_OpenStack') called
`deck'. Every player creates his own deck which consists of 52 different
open cards in our example.
     TMCG_OpenStack<VTMF_Card> deck;
     for (size_t type = 0; type < 52; type++)
     {
       VTMF_Card c;
       tmcg->TMCG_CreateOpenCard(c, vtmf, type);
       deck.push(type, c);
     }
Note that this card deck must be consistent for all players, that means,
the order of the open cards must be exactly the same for all players.


File: libTMCG.info,  Node: Shuffling the Deck,  Next: Drawing a Card from the Deck,  Prev: Creating the Deck,  Up: Operations on Stacks

3.4.2 Shuffling the Deck
------------------------

Each player must perform a shuffle of the deck, because only such a
procedure guarantees that no coalition has influence on the outcome.
Thus we build a shuffle chain such that every player shuffles the deck.
Consider the following code fragment for the player P_j.

   The regular stack `s' is initialized with open cards from `deck'.
Then each player shuffles the stack (see `TMCG_MixStack') and proves the
correctness of this operation (see `TMCG_ProveStackEquality').
Consequently, every player should verify these proofs (see
`TMCG_VerifyStackEquality').  Finally, the stack `s' contains the
shuffled result.
     TMCG_Stack<VTMF_Card> s;
     s.push(deck);

     for (size_t i = 0; i < 5; i++)
     {
       TMCG_Stack<VTMF_Card> s2;
       if (i == j)
       {
         TMCG_StackSecret<VTMF_CardSecret> ss;
         tmcg->TMCG_CreateStackSecret(ss, false, s.size(), vtmf);
         tmcg->TMCG_MixStack(s, s2, ss, vtmf);
         for (size_t i2 = 0; i2 < 5; i2++)
         {
           if (i2 == j)
             continue;
           out_stream[i2] << s2 << std::endl;
           tmcg->TMCG_ProveStackEquality(s, s2, ss, false, vtmf,
             in_stream[i2], out_stream[i2]);
         }
       }
       else
       {
         in_stream[i] >> s2;
         if (!in_stream[i].good())
           std::cerr << "Read or parse error!" << std::endl;
         if (!tmcg->TMCG_VerifyStackEquality(s, s2, false, vtmf,
           in_stream[i], out_stream[i]))
             std::cerr << "Verification failed!" << std::endl;
       }
       s = s2;
     }

   If you want to use the more efficient shuffle verification protocol
of Groth, then you must simply replace `TMCG_ProveStackEquality' and
`TMCG_VerifyStackEquality' by `TMCG_ProveStackEquality_Groth' and
`TMCG_VerifyStackEquality_Groth', respectively.


File: libTMCG.info,  Node: Drawing a Card from the Deck,  Prev: Shuffling the Deck,  Up: Operations on Stacks

3.4.3 Drawing a Card from the Deck
----------------------------------

Now every player has the same shuffled deck `s' and nobody knows in
which order the 52 cards are stacked. Therefore you can simply use any
drawing strategy to obtain a players hand. For example, look at the
following code that draws two cards from `s' for each player.
     TMCG_Stack<VTMF_Card> hand[5];
     for (size_t i = 0; i < 5; i++)
     {
       VTMF_Card c1, c2;
       s.pop(c1), s.pop(c2);
       hand[i].push(c1), hand[i].push(c2);
     }
Further, probably you want disclose the card types to the corresponding
player. Consider the code fragment for the player P_j: Every player
receives the necessary information from the other players and computes
the card types of his hand `hand[j]'. Finally, these types are stored
together with the masked cards in the open stack `private_hand'. The
example can be modified in a straightforward way to publicly disclose a
card from a players hand or from the remaining stack `s'.
     TMCG_OpenStack<VTMF_Card> private_hand;
     for (size_t i = 0; i < 5; i++)
     {
       if (i == j)
       {
         for (size_t k = 0; k < hand[j].size(); k++)
         {
           tmcg->TMCG_SelfCardSecret(hand[j][k], vtmf);
           for (size_t i2 = 0; i2 < 5; i2++)
           {
             if (i2 == j)
               continue;
             if (!tmcg->TMCG_VerifyCardSecret(hand[j][k], vtmf,
               in_stream[i2], out_stream[i2]))
                 std::cerr << "Verification failed!" << std::endl;
           }
           private_hand.push(tmcg->TMCG_TypeOfCard(hand[j][k], vtmf),
             hand[j][k]);
         }
       }
       else
       {
         for (size_t k = 0; k < hand[i].size(); k++)
         {
           tmcg->TMCG_ProveCardSecret(hand[i][k], vtmf,
             in_stream[i], out_stream[i]);
         }
       }
     }


File: libTMCG.info,  Node: Quit a Session,  Prev: Operations on Stacks,  Up: Examples

3.5 Quit a Session
==================

The last step should release all occupied resources.
     delete vsshe, delete vtmf, delete tmcg;


File: libTMCG.info,  Node: Licenses,  Next: General and API Index,  Prev: Examples,  Up: Top

Appendix A Licenses
*******************

A.1 GNU General Public License
==============================

                         Version 2, June 1991

     Copyright (C) 1989, 1991 Free Software Foundation, Inc.
     51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

Preamble
========

The licenses for most software are designed to take away your freedom
to share and change it.  By contrast, the GNU General Public License is
intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Lesser General Public License instead.)  You can apply it to
your programs, too.

   When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it in
new free programs; and that you know you can do these things.

   To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

   For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

   We protect your rights with two steps: (1) copyright the software,
and (2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

   Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

   Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

   The precise terms and conditions for copying, distribution and
modification follow.

    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
  0. This License applies to any program or other work which contains a
     notice placed by the copyright holder saying it may be distributed
     under the terms of this General Public License.  The "Program",
     below, refers to any such program or work, and a "work based on
     the Program" means either the Program or any derivative work under
     copyright law: that is to say, a work containing the Program or a
     portion of it, either verbatim or with modifications and/or
     translated into another language.  (Hereinafter, translation is
     included without limitation in the term "modification".)  Each
     licensee is addressed as "you".

     Activities other than copying, distribution and modification are
     not covered by this License; they are outside its scope.  The act
     of running the Program is not restricted, and the output from the
     Program is covered only if its contents constitute a work based on
     the Program (independent of having been made by running the
     Program).  Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
     source code as you receive it, in any medium, provided that you
     conspicuously and appropriately publish on each copy an appropriate
     copyright notice and disclaimer of warranty; keep intact all the
     notices that refer to this License and to the absence of any
     warranty; and give any other recipients of the Program a copy of
     this License along with the Program.

     You may charge a fee for the physical act of transferring a copy,
     and you may at your option offer warranty protection in exchange
     for a fee.

  2. You may modify your copy or copies of the Program or any portion
     of it, thus forming a work based on the Program, and copy and
     distribute such modifications or work under the terms of Section 1
     above, provided that you also meet all of these conditions:

       a. You must cause the modified files to carry prominent notices
          stating that you changed the files and the date of any change.

       b. You must cause any work that you distribute or publish, that
          in whole or in part contains or is derived from the Program
          or any part thereof, to be licensed as a whole at no charge
          to all third parties under the terms of this License.

       c. If the modified program normally reads commands interactively
          when run, you must cause it, when started running for such
          interactive use in the most ordinary way, to print or display
          an announcement including an appropriate copyright notice and
          a notice that there is no warranty (or else, saying that you
          provide a warranty) and that users may redistribute the
          program under these conditions, and telling the user how to
          view a copy of this License.  (Exception: if the Program
          itself is interactive but does not normally print such an
          announcement, your work based on the Program is not required
          to print an announcement.)

     These requirements apply to the modified work as a whole.  If
     identifiable sections of that work are not derived from the
     Program, and can be reasonably considered independent and separate
     works in themselves, then this License, and its terms, do not
     apply to those sections when you distribute them as separate
     works.  But when you distribute the same sections as part of a
     whole which is a work based on the Program, the distribution of
     the whole must be on the terms of this License, whose permissions
     for other licensees extend to the entire whole, and thus to each
     and every part regardless of who wrote it.

     Thus, it is not the intent of this section to claim rights or
     contest your rights to work written entirely by you; rather, the
     intent is to exercise the right to control the distribution of
     derivative or collective works based on the Program.

     In addition, mere aggregation of another work not based on the
     Program with the Program (or with a work based on the Program) on
     a volume of a storage or distribution medium does not bring the
     other work under the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
     under Section 2) in object code or executable form under the terms
     of Sections 1 and 2 above provided that you also do one of the
     following:

       a. Accompany it with the complete corresponding machine-readable
          source code, which must be distributed under the terms of
          Sections 1 and 2 above on a medium customarily used for
          software interchange; or,

       b. Accompany it with a written offer, valid for at least three
          years, to give any third party, for a charge no more than your
          cost of physically performing source distribution, a complete
          machine-readable copy of the corresponding source code, to be
          distributed under the terms of Sections 1 and 2 above on a
          medium customarily used for software interchange; or,

       c. Accompany it with the information you received as to the offer
          to distribute corresponding source code.  (This alternative is
          allowed only for noncommercial distribution and only if you
          received the program in object code or executable form with
          such an offer, in accord with Subsection b above.)

     The source code for a work means the preferred form of the work for
     making modifications to it.  For an executable work, complete
     source code means all the source code for all modules it contains,
     plus any associated interface definition files, plus the scripts
     used to control compilation and installation of the executable.
     However, as a special exception, the source code distributed need
     not include anything that is normally distributed (in either
     source or binary form) with the major components (compiler,
     kernel, and so on) of the operating system on which the executable
     runs, unless that component itself accompanies the executable.

     If distribution of executable or object code is made by offering
     access to copy from a designated place, then offering equivalent
     access to copy the source code from the same place counts as
     distribution of the source code, even though third parties are not
     compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense or distribute the Program is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses
     terminated so long as such parties remain in full compliance.

  5. You are not required to accept this License, since you have not
     signed it.  However, nothing else grants you permission to modify
     or distribute the Program or its derivative works.  These actions
     are prohibited by law if you do not accept this License.
     Therefore, by modifying or distributing the Program (or any work
     based on the Program), you indicate your acceptance of this
     License to do so, and all its terms and conditions for copying,
     distributing or modifying the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
     Program), the recipient automatically receives a license from the
     original licensor to copy, distribute or modify the Program
     subject to these terms and conditions.  You may not impose any
     further restrictions on the recipients' exercise of the rights
     granted herein.  You are not responsible for enforcing compliance
     by third parties to this License.

  7. If, as a consequence of a court judgment or allegation of patent
     infringement or for any other reason (not limited to patent
     issues), conditions are imposed on you (whether by court order,
     agreement or otherwise) that contradict the conditions of this
     License, they do not excuse you from the conditions of this
     License.  If you cannot distribute so as to satisfy simultaneously
     your obligations under this License and any other pertinent
     obligations, then as a consequence you may not distribute the
     Program at all.  For example, if a patent license would not permit
     royalty-free redistribution of the Program by all those who
     receive copies directly or indirectly through you, then the only
     way you could satisfy both it and this License would be to refrain
     entirely from distribution of the Program.

     If any portion of this section is held invalid or unenforceable
     under any particular circumstance, the balance of the section is
     intended to apply and the section as a whole is intended to apply
     in other circumstances.

     It is not the purpose of this section to induce you to infringe any
     patents or other property right claims or to contest validity of
     any such claims; this section has the sole purpose of protecting
     the integrity of the free software distribution system, which is
     implemented by public license practices.  Many people have made
     generous contributions to the wide range of software distributed
     through that system in reliance on consistent application of that
     system; it is up to the author/donor to decide if he or she is
     willing to distribute software through any other system and a
     licensee cannot impose that choice.

     This section is intended to make thoroughly clear what is believed
     to be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
     certain countries either by patents or by copyrighted interfaces,
     the original copyright holder who places the Program under this
     License may add an explicit geographical distribution limitation
     excluding those countries, so that distribution is permitted only
     in or among countries not thus excluded.  In such case, this
     License incorporates the limitation as if written in the body of
     this License.

  9. The Free Software Foundation may publish revised and/or new
     versions of the General Public License from time to time.  Such
     new versions will be similar in spirit to the present version, but
     may differ in detail to address new problems or concerns.

     Each version is given a distinguishing version number.  If the
     Program specifies a version number of this License which applies
     to it and "any later version", you have the option of following
     the terms and conditions either of that version or of any later
     version published by the Free Software Foundation.  If the Program
     does not specify a version number of this License, you may choose
     any version ever published by the Free Software Foundation.

 10. If you wish to incorporate parts of the Program into other free
     programs whose distribution conditions are different, write to the
     author to ask for permission.  For software which is copyrighted
     by the Free Software Foundation, write to the Free Software
     Foundation; we sometimes make exceptions for this.  Our decision
     will be guided by the two goals of preserving the free status of
     all derivatives of our free software and of promoting the sharing
     and reuse of software generally.

                                NO WARRANTY
 11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO
     WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE
     LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
     HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT
     WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT
     NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
     FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE
     QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
     PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY
     SERVICING, REPAIR OR CORRECTION.

 12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY
     MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE
     LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL,
     INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
     INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
     DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU
     OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY
     OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN
     ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

                      END OF TERMS AND CONDITIONS
Appendix: How to Apply These Terms to Your New Programs
=======================================================

If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

   To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

     ONE LINE TO GIVE THE PROGRAM'S NAME AND A BRIEF IDEA OF WHAT IT DOES.
     Copyright (C) YYYY  NAME OF AUTHOR

     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.

     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

   Also add information on how to contact you by electronic and paper
mail.

   If the program is interactive, make it output a short notice like
this when it starts in an interactive mode:

     Gnomovision version 69, Copyright (C) 19YY NAME OF AUTHOR
     Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type `show c' for details.

   The hypothetical commands `show w' and `show c' should show the
appropriate parts of the General Public License.  Of course, the
commands you use may be called something other than `show w' and `show
c'; they could even be mouse-clicks or menu items--whatever suits your
program.

   You should also get your employer (if you work as a programmer) or
your school, if any, to sign a "copyright disclaimer" for the program,
if necessary.  Here is a sample; alter the names:

     Yoyodyne, Inc., hereby disclaims all copyright interest in the program
     `Gnomovision' (which makes passes at compilers) written by James Hacker.

     SIGNATURE OF TY COON, 1 April 1989
     Ty Coon, President of Vice

   This General Public License does not permit incorporating your
program into proprietary programs.  If your program is a subroutine
library, you may consider it more useful to permit linking proprietary
applications with the library.  If this is what you want to do, use the
GNU Lesser General Public License instead of this License.

A.2 GNU Free Documentation License
==================================

                      Version 1.2, November 2002

     Copyright (C) 2000,2001,2002 Free Software Foundation, Inc.
     51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     functional and useful document "free" in the sense of freedom: to
     assure everyone the effective freedom to copy and redistribute it,
     with or without modifying it, either commercially or
     noncommercially.  Secondarily, this License preserves for the
     author and publisher a way to get credit for their work, while not
     being considered responsible for modifications made by others.

     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.
     We recommend this License principally for works whose purpose is
     instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work, in any medium,
     that contains a notice placed by the copyright holder saying it
     can be distributed under the terms of this License.  Such a notice
     grants a world-wide, royalty-free license, unlimited in duration,
     to use that work under the conditions stated herein.  The
     "Document", below, refers to any such manual or work.  Any member
     of the public is a licensee, and is addressed as "you".  You
     accept the license if you copy, modify or distribute the work in a
     way requiring permission under copyright law.

     A "Modified Version" of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A "Secondary Section" is a named appendix or a front-matter section
     of the Document that deals exclusively with the relationship of the
     publishers or authors of the Document to the Document's overall
     subject (or to related matters) and contains nothing that could
     fall directly within that overall subject.  (Thus, if the Document
     is in part a textbook of mathematics, a Secondary Section may not
     explain any mathematics.)  The relationship could be a matter of
     historical connection with the subject or with related matters, or
     of legal, commercial, philosophical, ethical or political position
     regarding them.

     The "Invariant Sections" are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in
     the notice that says that the Document is released under this
     License.  If a section does not fit the above definition of
     Secondary then it is not allowed to be designated as Invariant.
     The Document may contain zero Invariant Sections.  If the Document
     does not identify any Invariant Sections then there are none.

     The "Cover Texts" are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.  A
     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
     be at most 25 words.

     A "Transparent" copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, that is suitable for revising the document
     straightforwardly with generic text editors or (for images
     composed of pixels) generic paint programs or (for drawings) some
     widely available drawing editor, and that is suitable for input to
     text formatters or for automatic translation to a variety of
     formats suitable for input to text formatters.  A copy made in an
     otherwise Transparent file format whose markup, or absence of
     markup, has been arranged to thwart or discourage subsequent
     modification by readers is not Transparent.  An image format is
     not Transparent if used for any substantial amount of text.  A
     copy that is not "Transparent" is called "Opaque".

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and
     standard-conforming simple HTML, PostScript or PDF designed for
     human modification.  Examples of transparent image formats include
     PNG, XCF and JPG.  Opaque formats include proprietary formats that
     can be read and edited only by proprietary word processors, SGML or
     XML for which the DTD and/or processing tools are not generally
     available, and the machine-generated HTML, PostScript or PDF
     produced by some word processors for output purposes only.

     The "Title Page" means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, "Title
     Page" means the text near the most prominent appearance of the
     work's title, preceding the beginning of the body of the text.

     A section "Entitled XYZ" means a named subunit of the Document
     whose title either is precisely XYZ or contains XYZ in parentheses
     following text that translates XYZ in another language.  (Here XYZ
     stands for a specific section name mentioned below, such as
     "Acknowledgements", "Dedications", "Endorsements", or "History".)
     To "Preserve the Title" of such a section when you modify the
     Document means that it remains a section "Entitled XYZ" according
     to this definition.

     The Document may include Warranty Disclaimers next to the notice
     which states that this License applies to the Document.  These
     Warranty Disclaimers are considered to be included by reference in
     this License, but only as regards disclaiming warranties: any other
     implication that these Warranty Disclaimers may have is void and
     has no effect on the meaning of this License.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow
     the conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies (or copies in media that commonly
     have printed covers) of the Document, numbering more than 100, and
     the Document's license notice requires Cover Texts, you must
     enclose the copies in covers that carry, clearly and legibly, all
     these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the
     title equally prominent and visible.  You may add other material
     on the covers in addition.  Copying with changes limited to the
     covers, as long as they preserve the title of the Document and
     satisfy these conditions, can be treated as verbatim copying in
     other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a
     machine-readable Transparent copy along with each Opaque copy, or
     state in or with each Opaque copy a computer-network location from
     which the general network-using public has access to download
     using public-standard network protocols a complete Transparent
     copy of the Document, free of added material.  If you use the
     latter option, you must take reasonably prudent steps, when you
     begin distribution of Opaque copies in quantity, to ensure that
     this Transparent copy will remain thus accessible at the stated
     location until at least one year after the last time you
     distribute an Opaque copy (directly or through your agents or
     retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of
     copies, to give them a chance to provide you with an updated
     version of the Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with
     the Modified Version filling the role of the Document, thus
     licensing distribution and modification of the Modified Version to
     whoever possesses a copy of it.  In addition, you must do these
     things in the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of
          previous versions (which should, if there were any, be listed
          in the History section of the Document).  You may use the
          same title as a previous version if the original publisher of
          that version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has fewer than five), unless they release you
          from this requirement.

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document's
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section Entitled "History", Preserve its Title,
          and add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on
          the Title Page.  If there is no section Entitled "History" in
          the Document, create one stating the title, year, authors,
          and publisher of the Document as given on its Title Page,
          then add an item describing the Modified Version as stated in
          the previous sentence.

       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in
          the "History" section.  You may omit a network location for a
          work that was published at least four years before the
          Document itself, or if the original publisher of the version
          it refers to gives permission.

       K. For any section Entitled "Acknowledgements" or "Dedications",
          Preserve the Title of the section, and preserve in the
          section all the substance and tone of each of the contributor
          acknowledgements and/or dedications given therein.

       L. Preserve all the Invariant Sections of the Document,
          unaltered in their text and in their titles.  Section numbers
          or the equivalent are not considered part of the section
          titles.

       M. Delete any section Entitled "Endorsements".  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section to be Entitled
          "Endorsements" or to conflict in title with any Invariant
          Section.

       O. Preserve any Warranty Disclaimers.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option
     designate some or all of these sections as invariant.  To do this,
     add their titles to the list of Invariant Sections in the Modified
     Version's license notice.  These titles must be distinct from any
     other section titles.

     You may add a section Entitled "Endorsements", provided it contains
     nothing but endorsements of your Modified Version by various
     parties--for example, statements of peer review or that the text
     has been approved by an organization as the authoritative
     definition of a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end
     of the list of Cover Texts in the Modified Version.  Only one
     passage of Front-Cover Text and one of Back-Cover Text may be
     added by (or through arrangements made by) any one entity.  If the
     Document already includes a cover text for the same cover,
     previously added by you or by arrangement made by the same entity
     you are acting on behalf of, you may not add another; but you may
     replace the old one, on explicit permission from the previous
     publisher that added the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination
     all of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice, and that you preserve all
     their Warranty Disclaimers.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections Entitled
     "History" in the various original documents, forming one section
     Entitled "History"; likewise combine any sections Entitled
     "Acknowledgements", and any sections Entitled "Dedications".  You
     must delete all sections Entitled "Endorsements."

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the
     documents in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow
     this License in all other respects regarding verbatim copying of
     that document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of
     a storage or distribution medium, is called an "aggregate" if the
     copyright resulting from the compilation is not used to limit the
     legal rights of the compilation's users beyond what the individual
     works permit.  When the Document is included in an aggregate, this
     License does not apply to the other works in the aggregate which
     are not themselves derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one half
     of the entire aggregate, the Document's Cover Texts may be placed
     on covers that bracket the Document within the aggregate, or the
     electronic equivalent of covers if the Document is in electronic
     form.  Otherwise they must appear on printed covers that bracket
     the whole aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License, and all the license notices in the
     Document, and any Warranty Disclaimers, provided that you also
     include the original English version of this License and the
     original versions of those notices and disclaimers.  In case of a
     disagreement between the translation and the original version of
     this License or a notice or disclaimer, the original version will
     prevail.

     If a section in the Document is Entitled "Acknowledgements",
     "Dedications", or "History", the requirement (section 4) to
     Preserve its Title (section 1) will typically require changing the
     actual title.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided for under this License.  Any other
     attempt to copy, modify, sublicense or distribute the Document is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses
     terminated so long as such parties remain in full compliance.

 10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     `http://www.gnu.org/copyleft/'.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If
     the Document does not specify a version number of this License,
     you may choose any version ever published (not as a draft) by the
     Free Software Foundation.

ADDENDUM: How to use this License for your documents
====================================================

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.2
       or any later version published by the Free Software Foundation;
       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
       Texts.  A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.

   If you have Invariant Sections, Front-Cover Texts and Back-Cover
Texts, replace the "with...Texts." line with this:

         with the Invariant Sections being LIST THEIR TITLES, with
         the Front-Cover Texts being LIST, and with the Back-Cover Texts
         being LIST.

   If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License, to
permit their use in free software.


File: libTMCG.info,  Node: General and API Index,  Prev: Licenses,  Up: Top

Appendix B General and API Index
********************************

General Index
=============

 [index ]
* Menu:

* Card:                                  Terminology.         (line  15)
* Card Encoding Schemes:                 Data Types.          (line  12)
* Card Secret:                           Terminology.         (line  29)
* Card Type:                             Terminology.         (line  18)
* Classes:                               Classes.             (line   6)
* Data Types:                            Data Types.          (line   6)
* Examples:                              Examples.            (line   6)
* FDL, GNU Free Documentation License:   Licenses.            (line 364)
* GPL, GNU General Public License:       Licenses.            (line   9)
* Header Files:                          Header Files and Name Spaces.
                                                              (line   6)
* Initialization <1>:                    Session Initialization and Key Generation.
                                                              (line   6)
* Initialization <2>:                    Library Initialization.
                                                              (line   6)
* Initialization:                        Initializing the Library.
                                                              (line   6)
* Key Generation:                        Session Initialization and Key Generation.
                                                              (line   6)
* Keys:                                  Data Types.          (line 796)
* Masked Card:                           Terminology.         (line  39)
* Masking:                               Terminology.         (line  23)
* Name Spaces:                           Header Files and Name Spaces.
                                                              (line   6)
* Observer:                              Terminology.         (line  12)
* Open Card:                             Terminology.         (line  35)
* Player:                                Terminology.         (line   9)
* Private Card:                          Terminology.         (line  44)
* Prover:                                Terminology.         (line  52)
* Security:                              Security.            (line   6)
* Security Advice:                       Security.            (line  64)
* Security Parameters:                   Preprocessor Defined Global Symbols.
                                                              (line   6)
* Stack:                                 Terminology.         (line  49)
* Stacks:                                Data Types.          (line 380)
* Terminology:                           Terminology.         (line   6)
* Verifier:                              Terminology.         (line  52)

API Index
=========

 [index ]
* Menu:

* != on TMCG_Card:                       Data Types.         (line   90)
* != on TMCG_OpenStack:                  Data Types.         (line  577)
* != on TMCG_Stack:                      Data Types.         (line  430)
* != on VTMF_Card:                       Data Types.         (line  272)
* << on TMCG_Card:                       Data Types.         (line  117)
* << on TMCG_CardSecret:                 Data Types.         (line  210)
* << on TMCG_PublicKey:                  Data Types.         (line 1212)
* << on TMCG_SecretKey:                  Data Types.         (line 1032)
* << on TMCG_Stack:                      Data Types.         (line  528)
* << on TMCG_StackSecret:                Data Types.         (line  783)
* << on VTMF_Card:                       Data Types.         (line  290)
* << on VTMF_CardSecret:                 Data Types.         (line  366)
* = on TMCG_Card:                        Data Types.         (line   78)
* = on TMCG_CardSecret:                  Data Types.         (line  181)
* = on TMCG_OpenStack:                   Data Types.         (line  562)
* = on TMCG_PublicKey:                   Data Types.         (line 1125)
* = on TMCG_SecretKey:                   Data Types.         (line  929)
* = on TMCG_Stack:                       Data Types.         (line  414)
* = on TMCG_StackSecret:                 Data Types.         (line  710)
* = on VTMF_Card:                        Data Types.         (line  260)
* = on VTMF_CardSecret:                  Data Types.         (line  349)
* == on TMCG_Card:                       Data Types.         (line   84)
* == on TMCG_OpenStack:                  Data Types.         (line  569)
* == on TMCG_Stack:                      Data Types.         (line  421)
* == on VTMF_Card:                       Data Types.         (line  266)
* >> on TMCG_Card:                       Data Types.         (line  122)
* >> on TMCG_CardSecret:                 Data Types.         (line  216)
* >> on TMCG_PublicKey:                  Data Types.         (line 1216)
* >> on TMCG_SecretKey:                  Data Types.         (line 1036)
* >> on TMCG_Stack:                      Data Types.         (line  532)
* >> on TMCG_StackSecret:                Data Types.         (line  788)
* >> on VTMF_Card:                       Data Types.         (line  296)
* >> on VTMF_CardSecret:                 Data Types.         (line  372)
* [ on TMCG_OpenStack:                   Data Types.         (line  586)
* [ on TMCG_Stack:                       Data Types.         (line  438)
* [ on TMCG_StackSecret:                 Data Types.         (line  717)
* AM_PATH_LIBTMCG:                       Building Sources.   (line   53)
* BarnettSmartVTMF_dlog:                 Classes.            (line   43)
* BarnettSmartVTMF_dlog on BarnettSmartVTMF_dlog: Classes.   (line   93)
* BarnettSmartVTMF_dlog_GroupQR:         Classes.            (line  203)
* BarnettSmartVTMF_dlog_GroupQR on BarnettSmartVTMF_dlog_GroupQR: Classes.
                                                             (line  254)
* check on TMCG_PublicKey:               Data Types.         (line 1131)
* check on TMCG_SecretKey:               Data Types.         (line  935)
* CheckGroup on BarnettSmartVTMF_dlog:   Classes.            (line  125)
* CheckGroup on BarnettSmartVTMF_dlog_GroupQR: Classes.      (line  289)
* CheckGroup on GrothVSSHE:              Classes.            (line  468)
* clear on TMCG_OpenStack:               Data Types.         (line  645)
* clear on TMCG_Stack:                   Data Types.         (line  491)
* clear on TMCG_StackSecret:             Data Types.         (line  747)
* decrypt on TMCG_SecretKey:             Data Types.         (line  995)
* empty on TMCG_OpenStack:               Data Types.         (line  630)
* empty on TMCG_Stack:                   Data Types.         (line  477)
* encrypt on TMCG_PublicKey:             Data Types.         (line 1191)
* encrypt on TMCG_SecretKey:             Data Types.         (line 1011)
* find on TMCG_OpenStack:                Data Types.         (line  651)
* find on TMCG_Stack:                    Data Types.         (line  497)
* find on TMCG_StackSecret:              Data Types.         (line  765)
* find_position on TMCG_StackSecret:     Data Types.         (line  754)
* fingerprint on TMCG_PublicKey:         Data Types.         (line 1141)
* fingerprint on TMCG_SecretKey:         Data Types.         (line  945)
* GrothVSSHE:                            Classes.            (line  400)
* GrothVSSHE on GrothVSSHE:              Classes.            (line  414)
* import on TMCG_Card:                   Data Types.         (line  106)
* import on TMCG_CardSecret:             Data Types.         (line  198)
* import on TMCG_PublicKey:              Data Types.         (line 1183)
* import on TMCG_SecretKey:              Data Types.         (line  987)
* import on TMCG_Stack:                  Data Types.         (line  517)
* import on TMCG_StackSecret:            Data Types.         (line  772)
* import on VTMF_Card:                   Data Types.         (line  278)
* import on VTMF_CardSecret:             Data Types.         (line  355)
* init_libTMCG:                          Initializing the Library.
                                                             (line   11)
* KeyGenerationProtocol_Finalize on BarnettSmartVTMF_dlog: Classes.
                                                             (line  192)
* KeyGenerationProtocol_Finalize on BarnettSmartVTMF_dlog_GroupQR: Classes.
                                                             (line  356)
* KeyGenerationProtocol_GenerateKey on BarnettSmartVTMF_dlog: Classes.
                                                             (line  148)
* KeyGenerationProtocol_GenerateKey on BarnettSmartVTMF_dlog_GroupQR: Classes.
                                                             (line  312)
* KeyGenerationProtocol_PublishKey on BarnettSmartVTMF_dlog: Classes.
                                                             (line  158)
* KeyGenerationProtocol_PublishKey on BarnettSmartVTMF_dlog_GroupQR: Classes.
                                                             (line  322)
* KeyGenerationProtocol_RemoveKey on BarnettSmartVTMF_dlog: Classes.
                                                             (line  181)
* KeyGenerationProtocol_RemoveKey on BarnettSmartVTMF_dlog_GroupQR: Classes.
                                                             (line  345)
* KeyGenerationProtocol_UpdateKey on BarnettSmartVTMF_dlog: Classes.
                                                             (line  171)
* KeyGenerationProtocol_UpdateKey on BarnettSmartVTMF_dlog_GroupQR: Classes.
                                                             (line  335)
* keyid on TMCG_PublicKey:               Data Types.         (line 1160)
* keyid on TMCG_SecretKey:               Data Types.         (line  964)
* keyid_size on TMCG_PublicKey:          Data Types.         (line 1169)
* keyid_size on TMCG_SecretKey:          Data Types.         (line  973)
* move on TMCG_OpenStack:                Data Types.         (line  673)
* pop on TMCG_OpenStack:                 Data Types.         (line  637)
* pop on TMCG_Stack:                     Data Types.         (line  483)
* PublishGroup on BarnettSmartVTMF_dlog: Classes.            (line  138)
* PublishGroup on BarnettSmartVTMF_dlog_GroupQR: Classes.    (line  302)
* PublishGroup on GrothVSSHE:            Classes.            (line  475)
* push on TMCG_OpenStack:                Data Types.         (line  607)
* push on TMCG_Stack:                    Data Types.         (line  457)
* push on TMCG_StackSecret:              Data Types.         (line  740)
* remove on TMCG_OpenStack:              Data Types.         (line  657)
* remove on TMCG_Stack:                  Data Types.         (line  503)
* removeAll on TMCG_OpenStack:           Data Types.         (line  665)
* removeAll on TMCG_Stack:               Data Types.         (line  510)
* resize on TMCG_Card:                   Data Types.         (line   96)
* resize on TMCG_CardSecret:             Data Types.         (line  187)
* SchindelhauerTMCG:                     Classes.            (line  495)
* SchindelhauerTMCG on SchindelhauerTMCG: Classes.           (line  539)
* selfid on TMCG_PublicKey:              Data Types.         (line 1150)
* selfid on TMCG_SecretKey:              Data Types.         (line  954)
* sigid on TMCG_PublicKey:               Data Types.         (line 1176)
* sigid on TMCG_SecretKey:               Data Types.         (line  980)
* sign on TMCG_SecretKey:                Data Types.         (line 1005)
* size on TMCG_OpenStack:                Data Types.         (line  601)
* size on TMCG_Stack:                    Data Types.         (line  452)
* size on TMCG_StackSecret:              Data Types.         (line  733)
* TMCG_Card:                             Data Types.         (line   35)
* TMCG_Card on TMCG_Card:                Data Types.         (line   55)
* TMCG_CardSecret:                       Data Types.         (line  128)
* TMCG_CardSecret on TMCG_CardSecret:    Data Types.         (line  155)
* TMCG_CreateCardSecret on SchindelhauerTMCG: Classes.       (line  610)
* TMCG_CreateOpenCard on SchindelhauerTMCG: Classes.         (line  580)
* TMCG_CreatePrivateCard on SchindelhauerTMCG: Classes.      (line  639)
* TMCG_CreateStackSecret on SchindelhauerTMCG: Classes.      (line  949)
* TMCG_DDH_SIZE:                         Preprocessor Defined Global Symbols.
                                                             (line   22)
* TMCG_DLSE_SIZE:                        Preprocessor Defined Global Symbols.
                                                             (line   28)
* TMCG_GCRY_MD_ALGO:                     Preprocessor Defined Global Symbols.
                                                             (line   34)
* TMCG_GROTH_L_E:                        Preprocessor Defined Global Symbols.
                                                             (line   16)
* TMCG_HASH_COMMITMENT:                  Preprocessor Defined Global Symbols.
                                                             (line  142)
* TMCG_KEY_NIZK_STAGE1:                  Preprocessor Defined Global Symbols.
                                                             (line   65)
* TMCG_KEY_NIZK_STAGE2:                  Preprocessor Defined Global Symbols.
                                                             (line   73)
* TMCG_KEY_NIZK_STAGE3:                  Preprocessor Defined Global Symbols.
                                                             (line   80)
* TMCG_KEYID_SIZE:                       Preprocessor Defined Global Symbols.
                                                             (line   51)
* TMCG_LIBGCRYPT_VERSION:                Preprocessor Defined Global Symbols.
                                                             (line   87)
* TMCG_LIBGMP_VERSION:                   Preprocessor Defined Global Symbols.
                                                             (line   94)
* TMCG_MaskCard on SchindelhauerTMCG:    Classes.            (line  688)
* TMCG_MAX_CARDS:                        Preprocessor Defined Global Symbols.
                                                             (line  102)
* TMCG_MAX_FPOWM_T:                      Preprocessor Defined Global Symbols.
                                                             (line  150)
* TMCG_MAX_PLAYERS:                      Preprocessor Defined Global Symbols.
                                                             (line  106)
* TMCG_MAX_TYPEBITS:                     Preprocessor Defined Global Symbols.
                                                             (line  111)
* TMCG_MixStack on SchindelhauerTMCG:    Classes.            (line  998)
* TMCG_MPZ_IO_BASE:                      Preprocessor Defined Global Symbols.
                                                             (line  118)
* TMCG_MR_ITERATIONS:                    Preprocessor Defined Global Symbols.
                                                             (line   11)
* TMCG_OpenStack on TMCG_OpenStack:      Data Types.         (line  555)
* TMCG_OpenStack<:                       Data Types.         (line  537)
* TMCG_PRAB_K0:                          Preprocessor Defined Global Symbols.
                                                             (line  124)
* TMCG_ProveCardSecret on SchindelhauerTMCG: Classes.        (line  802)
* TMCG_ProveMaskCard on SchindelhauerTMCG: Classes.          (line  729)
* TMCG_ProveStackEquality on SchindelhauerTMCG: Classes.     (line 1038)
* TMCG_ProveStackEquality_Groth on SchindelhauerTMCG: Classes.
                                                             (line 1087)
* TMCG_PublicKey:                        Data Types.         (line 1041)
* TMCG_PublicKey on TMCG_PublicKey:      Data Types.         (line 1104)
* TMCG_PublicKeyRing:                    Data Types.         (line 1221)
* TMCG_PublicKeyRing on TMCG_PublicKeyRing: Data Types.      (line 1235)
* TMCG_QRA_SIZE:                         Preprocessor Defined Global Symbols.
                                                             (line  130)
* TMCG_SAEP_S0:                          Preprocessor Defined Global Symbols.
                                                             (line  136)
* TMCG_SecretKey:                        Data Types.         (line  810)
* TMCG_SecretKey on TMCG_SecretKey:      Data Types.         (line  891)
* TMCG_SelfCardSecret on SchindelhauerTMCG: Classes.         (line  882)
* TMCG_Stack on TMCG_Stack:              Data Types.         (line  407)
* TMCG_Stack<:                           Data Types.         (line  387)
* TMCG_StackSecret on TMCG_StackSecret:  Data Types.         (line  703)
* TMCG_StackSecret<:                     Data Types.         (line  683)
* TMCG_TypeOfCard on SchindelhauerTMCG:  Classes.            (line  917)
* TMCG_VerifyCardSecret on SchindelhauerTMCG: Classes.       (line  837)
* TMCG_VerifyMaskCard on SchindelhauerTMCG: Classes.         (line  766)
* TMCG_VerifyStackEquality on SchindelhauerTMCG: Classes.    (line 1100)
* TMCG_VerifyStackEquality_Groth on SchindelhauerTMCG: Classes.
                                                             (line 1144)
* verify on TMCG_PublicKey:              Data Types.         (line 1201)
* verify on TMCG_SecretKey:              Data Types.         (line 1021)
* version_libTMCG:                       Initializing the Library.
                                                             (line   22)
* VTMF_Card:                             Data Types.         (line  223)
* VTMF_Card on VTMF_Card:                Data Types.         (line  247)
* VTMF_CardSecret:                       Data Types.         (line  303)
* VTMF_CardSecret on VTMF_CardSecret:    Data Types.         (line  335)
* ~BarnettSmartVTMF_dlog on BarnettSmartVTMF_dlog: Classes.  (line  200)
* ~BarnettSmartVTMF_dlog_GroupQR on BarnettSmartVTMF_dlog_GroupQR: Classes.
                                                             (line  365)
* ~GrothVSSHE on GrothVSSHE:             Classes.            (line  483)
* ~SchindelhauerTMCG on SchindelhauerTMCG: Classes.          (line 1154)
* ~TMCG_Card on TMCG_Card:               Data Types.         (line  113)
* ~TMCG_CardSecret on TMCG_CardSecret:   Data Types.         (line  206)
* ~TMCG_OpenStack on TMCG_OpenStack:     Data Types.         (line  680)
* ~TMCG_PublicKey on TMCG_PublicKey:     Data Types.         (line 1208)
* ~TMCG_PublicKeyRing on TMCG_PublicKeyRing: Data Types.     (line 1248)
* ~TMCG_SecretKey on TMCG_SecretKey:     Data Types.         (line 1028)
* ~TMCG_Stack on TMCG_Stack:             Data Types.         (line  524)
* ~TMCG_StackSecret on TMCG_StackSecret: Data Types.         (line  779)
* ~VTMF_Card on VTMF_Card:               Data Types.         (line  286)
* ~VTMF_CardSecret on VTMF_CardSecret:   Data Types.         (line  362)



Tag Table:
Node: Top658
Node: Introduction1478
Node: Further Reading3672
Node: Getting Started5126
Node: Preliminaries5804
Node: Terminology6334
Node: Security8606
Ref: Security-Footnote-112706
Node: Preparation12807
Node: Header Files and Name Spaces14194
Ref: Header Files and Name Spaces-Footnote-115224
Node: Building Sources15480
Node: Initializing the Library18260
Node: Application Programming Interface19271
Node: Preprocessor Defined Global Symbols19533
Ref: Preprocessor Defined Global Symbols-Footnote-127262
Node: Data Types and Classes27324
Node: Data Types27728
Ref: Data Types-Footnote-171744
Node: Classes71849
Ref: Classes-Footnote-1125998
Node: Examples126204
Ref: Examples-Footnote-1127378
Node: Library Initialization127486
Node: Session Initialization and Key Generation128056
Node: Operations on Cards132971
Node: Creating an Open Card133493
Node: Masking and Re-masking of a Card133824
Node: Opening a Masked Card135270
Node: Operations on Stacks136269
Node: Creating the Deck136827
Node: Shuffling the Deck137558
Node: Drawing a Card from the Deck139555
Node: Quit a Session141535
Node: Licenses141762
Node: General and API Index183313

End Tag Table
